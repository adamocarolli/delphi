

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>delphi.translators.for2py.genPGM &mdash; delphi  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../../../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script type="text/javascript" src="../../../../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/css/custom.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/collapsible-lists/css/tree_view.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> delphi
          

          
            
            <img src="../../../../_static/delphi_logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model.html">The Delphi model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../AnalysisGraph_API.html">AnalysisGraph API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../GrFN_API.html">GroundedFunctionNetwork API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../grfn_spec.html">Grounded Function Network (GrFN) JSON Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../grfn_spec.html#change-log">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../CONTRIBUTING.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../cpp_api/library_root.html">C++ API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">delphi</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../for2py.html">delphi.translators.for2py</a> &raquo;</li>
        
      <li>delphi.translators.for2py.genPGM</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for delphi.translators.for2py.genPGM</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/python3.6</span>

<span class="kn">import</span> <span class="nn">ast</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">tokenize</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="k">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">reduce</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">from</span> <span class="nn">delphi.translators.for2py.genCode</span> <span class="k">import</span> <span class="n">genCode</span><span class="p">,</span> <span class="n">PrintState</span>
<span class="kn">from</span> <span class="nn">delphi.translators.for2py.mod_index_generator</span> <span class="k">import</span> <span class="n">get_index</span>
<span class="kn">from</span> <span class="nn">delphi.translators.for2py</span> <span class="k">import</span> <span class="n">For2PyError</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">chain</span><span class="p">,</span> <span class="n">product</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">uuid</span>

<span class="c1">###########################################################################</span>
<span class="c1">#                                                                         #</span>
<span class="c1">#                            GLOBAL VARIABLES                             #</span>
<span class="c1">#                                                                         #</span>
<span class="c1">###########################################################################</span>

<span class="c1"># The BINOPS dictionary holds operators for all the arithmetic and</span>
<span class="c1"># comparative functions</span>
<span class="n">BINOPS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">Add</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">Sub</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">Mult</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">Div</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">,</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">Pow</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">pow</span><span class="p">,</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">Eq</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">,</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">LtE</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1"># The ANNOTATE_MAP dictionary is used to map Python ast data types into data</span>
<span class="c1"># types for the lambdas</span>
<span class="n">ANNOTATE_MAP</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;real&quot;</span><span class="p">:</span> <span class="s2">&quot;Real&quot;</span><span class="p">,</span>
    <span class="s2">&quot;float&quot;</span><span class="p">:</span> <span class="s2">&quot;real&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Real&quot;</span><span class="p">:</span> <span class="s2">&quot;real&quot;</span><span class="p">,</span>
    <span class="s2">&quot;integer&quot;</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span>
    <span class="s2">&quot;int&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">,</span>
    <span class="s2">&quot;string&quot;</span><span class="p">:</span> <span class="s2">&quot;str&quot;</span><span class="p">,</span>
    <span class="s2">&quot;str&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span>
    <span class="s2">&quot;array&quot;</span><span class="p">:</span> <span class="s2">&quot;[]&quot;</span><span class="p">,</span>
    <span class="s2">&quot;list&quot;</span><span class="p">:</span> <span class="s2">&quot;array&quot;</span><span class="p">,</span>
    <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1"># The UNNECESSARY_TYPES tuple holds the ast types to ignore</span>
<span class="n">UNNECESSARY_TYPES</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">Mult</span><span class="p">,</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">Add</span><span class="p">,</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">Sub</span><span class="p">,</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">Pow</span><span class="p">,</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">Div</span><span class="p">,</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">USub</span><span class="p">,</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">Eq</span><span class="p">,</span>
    <span class="n">ast</span><span class="o">.</span><span class="n">LtE</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># Regular expression to match python statements that need to be bypassed in</span>
<span class="c1"># the GrFN and lambda files. Currently contains I/O statements.</span>
<span class="n">BYPASS_IO</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;^format_\d+$|^format_\d+_obj$|^file_\d+$|^write_list_\d+$|&quot;</span> \
            <span class="sa">r</span><span class="s2">&quot;^write_line$|^format_\d+_obj&quot;</span> \
            <span class="sa">r</span><span class="s2">&quot;.*|^Format$|^list_output_formats$|^write_list_stream$&quot;</span>
<span class="n">RE_BYPASS_IO</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">BYPASS_IO</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>


<div class="viewcode-block" id="GrFNState"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNState">[docs]</a><span class="k">class</span> <span class="nc">GrFNState</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lambda_strings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
        <span class="n">last_definitions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">next_definitions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">last_definition_default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">function_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">variable_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">scope_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lambda_strings</span> <span class="o">=</span> <span class="n">lambda_strings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_definitions</span> <span class="o">=</span> <span class="n">last_definitions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_definitions</span> <span class="o">=</span> <span class="n">next_definitions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_definition_default</span> <span class="o">=</span> <span class="n">last_definition_default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_name</span> <span class="o">=</span> <span class="n">function_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable_types</span> <span class="o">=</span> <span class="n">variable_types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scope_path</span> <span class="o">=</span> <span class="n">scope_path</span>

<div class="viewcode-block" id="GrFNState.copy"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNState.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lambda_strings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">last_definitions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">next_definitions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">last_definition_default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">function_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">variable_types</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scope_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="n">GrFNState</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lambda_strings</span> <span class="k">if</span> <span class="n">lambda_strings</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">lambda_strings</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_definitions</span> <span class="k">if</span> <span class="n">last_definitions</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span>
            <span class="n">last_definitions</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">next_definitions</span> <span class="k">if</span> <span class="n">next_definitions</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span>
            <span class="n">next_definitions</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_definition_default</span> <span class="k">if</span> <span class="n">last_definition_default</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">last_definition_default</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">function_name</span> <span class="k">if</span> <span class="n">function_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">function_name</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variable_types</span> <span class="k">if</span> <span class="n">variable_types</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">variable_types</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">start</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scope_path</span> <span class="k">if</span> <span class="n">scope_path</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">scope_path</span><span class="p">,</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="GrFNGenerator"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator">[docs]</a><span class="k">class</span> <span class="nc">GrFNGenerator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">annotated_assigned</span><span class="o">=</span><span class="p">[],</span>
                 <span class="n">elif_grfn</span><span class="o">=</span><span class="p">[],</span>
                 <span class="n">function_definitions</span><span class="o">=</span><span class="p">[]</span>
                 <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annotated_assigned</span> <span class="o">=</span> <span class="n">annotated_assigned</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elif_grfn</span> <span class="o">=</span> <span class="n">elif_grfn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_definitions</span> <span class="o">=</span> <span class="n">function_definitions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fortran_file</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exclude_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode_mapper</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alias_mapper</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name_mapper</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_names</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outer_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">FunctionDef</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">process_grfn</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;ast.FunctionDef&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_function_definition</span><span class="p">,</span>
            <span class="s2">&quot;ast.arguments&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_arguments</span><span class="p">,</span>
            <span class="s2">&quot;ast.arg&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_arg</span><span class="p">,</span>
            <span class="s2">&quot;ast.Load&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_load</span><span class="p">,</span>
            <span class="s2">&quot;ast.Store&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_store</span><span class="p">,</span>
            <span class="s2">&quot;ast.Index&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_index</span><span class="p">,</span>
            <span class="s2">&quot;ast.Num&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_num</span><span class="p">,</span>
            <span class="s2">&quot;ast.List&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_list_ast</span><span class="p">,</span>
            <span class="s2">&quot;ast.Str&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_str</span><span class="p">,</span>
            <span class="s2">&quot;ast.For&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_for</span><span class="p">,</span>
            <span class="s2">&quot;ast.If&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_if</span><span class="p">,</span>
            <span class="s2">&quot;ast.UnaryOp&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_unary_operation</span><span class="p">,</span>
            <span class="s2">&quot;ast.BinOp&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_binary_operation</span><span class="p">,</span>
            <span class="s2">&quot;ast.BoolOp&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_boolean_operation</span><span class="p">,</span>
            <span class="s2">&quot;ast.Expr&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_expression</span><span class="p">,</span>
            <span class="s2">&quot;ast.Compare&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_compare</span><span class="p">,</span>
            <span class="s2">&quot;ast.Subscript&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_subscript</span><span class="p">,</span>
            <span class="s2">&quot;ast.Name&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_name</span><span class="p">,</span>
            <span class="s2">&quot;ast.AnnAssign&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_annotated_assign</span><span class="p">,</span>
            <span class="s2">&quot;ast.Assign&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_assign</span><span class="p">,</span>
            <span class="s2">&quot;ast.Tuple&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_tuple</span><span class="p">,</span>
            <span class="s2">&quot;ast.Call&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_call</span><span class="p">,</span>
            <span class="s2">&quot;ast.Module&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_module</span><span class="p">,</span>
            <span class="s2">&quot;ast.Attribute&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_attribute</span><span class="p">,</span>
            <span class="s2">&quot;ast.AST&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_ast</span><span class="p">,</span>
        <span class="p">}</span>

<div class="viewcode-block" id="GrFNGenerator.gen_grfn"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.gen_grfn">[docs]</a>    <span class="k">def</span> <span class="nf">gen_grfn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function generates the GrFN structure by parsing through the</span>
<span class="sd">            python AST</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Look for code that is not inside any function. This will generally</span>
        <span class="c1"># involve</span>
        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">function_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">types</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Call</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;start&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">id</span><span class="p">}]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Expr</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;start&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">If</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;start&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_list</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">node_type</span><span class="p">)</span> <span class="k">for</span> <span class="n">node_type</span> <span class="ow">in</span>
                 <span class="n">UNNECESSARY_TYPES</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_unnecessary_types</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node_name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">:]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_grfn</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node_name</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_grfn</span><span class="p">[</span><span class="n">node_name</span><span class="p">](</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_nomatch</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">)</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_list"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_list">[docs]</a>    <span class="k">def</span> <span class="nf">process_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         If there are one or more ast nodes inside the `body` of a node,</span>
<span class="sd">         there appear as a list. Process each node in the list and chain them</span>
<span class="sd">         together into a single list of GrFN dictionaries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">cur</span> <span class="ow">in</span> <span class="n">node</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_function_definition"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_function_definition">[docs]</a>    <span class="k">def</span> <span class="nf">process_function_definition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function processes the function definition i.e. functionDef</span>
<span class="sd">            instance. It appends GrFN dictionaries to the `functions` key in</span>
<span class="sd">            the main GrFN JSON. These dictionaries consist of the</span>
<span class="sd">            function_assign_grfn of the function body and the</span>
<span class="sd">            function_container_grfn of the function. Every call to this</span>
<span class="sd">            function adds these along with the identifier_spec_grfn to the</span>
<span class="sd">            main GrFN JSON.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Add the function name to the list that stores all the functions</span>
        <span class="c1"># defined in the program</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_definitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="n">local_last_definitions</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">local_next_definitions</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">local_variable_types</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">scope_path</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">scope_path</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># If the scope_path is empty, add _TOP to the list to denote that</span>
        <span class="c1"># this is the outermost scope</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scope_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">scope_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;_TOP&quot;</span><span class="p">)</span>
        <span class="n">scope_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">decorator_list</span><span class="p">:</span>
            <span class="c1"># This is still a work-in-progress function since a complete</span>
            <span class="c1"># representation of SAVEd variables has not been decided for GrFN.</span>
            <span class="c1"># Currently, if the decorator function is static_vars (for</span>
            <span class="c1"># SAVEd variables), their types are loaded in the variable_types</span>
            <span class="c1"># dictionary.</span>
            <span class="n">function_state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                <span class="n">last_definitions</span><span class="o">=</span><span class="n">local_last_definitions</span><span class="p">,</span>
                <span class="n">next_definitions</span><span class="o">=</span><span class="n">local_next_definitions</span><span class="p">,</span>
                <span class="n">function_name</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="n">variable_types</span><span class="o">=</span><span class="n">local_variable_types</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">process_decorators</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">decorator_list</span><span class="p">,</span> <span class="n">function_state</span><span class="p">)</span>

        <span class="c1"># Check if the function contains arguments or not. This determines</span>
        <span class="c1"># whether the function is the outermost scope (does not contain</span>
        <span class="c1"># arguments) or it is not (contains arguments). For non-outermost</span>
        <span class="c1"># scopes, indexing starts from -1. For outermost scopes, indexing</span>
        <span class="c1"># starts from 0</span>
        <span class="c1"># TODO: What do you do when a non-outermost scope function does not</span>
        <span class="c1">#  have arguments. Current assumption is that the function without</span>
        <span class="c1">#  arguments is the outermost function i.e. call to the `start`</span>
        <span class="c1">#  function. But there can be functions without arguments which are not</span>
        <span class="c1">#  the `start` functions but instead some inner functions.</span>

        <span class="c1"># The following is a test to make sure that there is only one</span>
        <span class="c1"># function without arguments and that is the outermost function. All</span>
        <span class="c1"># of the models that we currently handle have this structure and</span>
        <span class="c1"># we&#39;ll have to think about how to handle cases that have more than</span>
        <span class="c1"># one non-argument function.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outer_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">outer_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;There is more than one function &quot;</span> \
                                          <span class="s2">&quot;without arguments in this system. &quot;</span> \
                                          <span class="s2">&quot;This is not currently handled.&quot;</span>

            <span class="n">function_state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                <span class="n">last_definitions</span><span class="o">=</span><span class="n">local_last_definitions</span><span class="p">,</span>
                <span class="n">next_definitions</span><span class="o">=</span><span class="n">local_next_definitions</span><span class="p">,</span>
                <span class="n">function_name</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="n">variable_types</span><span class="o">=</span><span class="n">local_variable_types</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">function_state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                <span class="n">last_definitions</span><span class="o">=</span><span class="p">{},</span>
                <span class="n">next_definitions</span><span class="o">=</span><span class="p">{},</span>
                <span class="n">function_name</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="n">variable_types</span><span class="o">=</span><span class="n">local_variable_types</span><span class="p">,</span>
                <span class="n">last_definition_default</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Get the list of arguments from the function definition</span>
        <span class="n">argument_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">function_state</span><span class="p">,</span> <span class="s2">&quot;functiondef&quot;</span><span class="p">)</span>
        <span class="c1"># Enter the body of the function and recursively generate the GrFN of</span>
        <span class="c1"># the function body</span>
        <span class="n">body_grfn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">function_state</span><span class="p">,</span> <span class="s2">&quot;functiondef&quot;</span><span class="p">)</span>
        <span class="c1"># Get the function_reference_spec, function_assign_spec and</span>
        <span class="c1"># identifier_spec for the function</span>
        <span class="n">function_reference_grfn</span><span class="p">,</span> <span class="n">function_assign_grfn</span><span class="p">,</span> <span class="n">identifier_grfn</span> <span class="o">=</span> \
            <span class="n">get_body_and_functions</span><span class="p">(</span><span class="n">body_grfn</span><span class="p">)</span>

        <span class="c1"># This function removes all variables related to I/O from the</span>
        <span class="c1"># variable list. This will be done until a specification for I/O is</span>
        <span class="c1"># defined in GrFN</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="n">remove_io_variables</span><span class="p">(</span>
                        <span class="nb">list</span><span class="p">(</span><span class="n">local_last_definitions</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="n">function_container_grfn</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;container&quot;</span><span class="p">,</span>
            <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">arg</span><span class="p">,</span> <span class="s2">&quot;domain&quot;</span><span class="p">:</span> <span class="n">local_variable_types</span><span class="p">[</span><span class="n">arg</span><span class="p">]}</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span>
                <span class="n">argument_list</span>
            <span class="p">],</span>
            <span class="s2">&quot;variables&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">var</span><span class="p">,</span> <span class="s2">&quot;domain&quot;</span><span class="p">:</span> <span class="n">local_variable_types</span><span class="p">[</span><span class="n">var</span><span class="p">]}</span>
                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span>
            <span class="p">],</span>
            <span class="s2">&quot;body&quot;</span><span class="p">:</span> <span class="n">function_reference_grfn</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">function_assign_grfn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">function_container_grfn</span><span class="p">)</span>

        <span class="n">pgm</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;functions&quot;</span><span class="p">:</span> <span class="n">function_assign_grfn</span><span class="p">,</span>
               <span class="s2">&quot;identifiers&quot;</span><span class="p">:</span> <span class="n">identifier_grfn</span><span class="p">}</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">pgm</span><span class="p">]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_arguments"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_arguments">[docs]</a>    <span class="k">def</span> <span class="nf">process_arguments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function returns a list of arguments defined in a function</span>
<span class="sd">            definition. `node.args` is a list of `arg` nodes which are</span>
<span class="sd">            iteratively processed to get the argument name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span>
        <span class="p">]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_arg"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_arg">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">process_arg</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function processes a function argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Variables are declared as List() objects in the intermediate Python</span>
        <span class="c1"># representation in order to mimic the pass-by-reference property of</span>
        <span class="c1"># Fortran. So, arguments have `annotations` which hold the type() of</span>
        <span class="c1"># the variable i.e. x[Int], y[Float], etc.</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">node</span><span class="o">.</span><span class="n">annotation</span>
        <span class="p">),</span> <span class="s2">&quot;Found argument without annotation. This should not happen.&quot;</span>
        <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_variable_type</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">annotation</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">call_source</span> <span class="o">==</span> <span class="s2">&quot;functiondef&quot;</span><span class="p">:</span>
                <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;Call source is not ast.FunctionDef. &quot;</span>
                               <span class="s2">&quot;Handle this by setting state.last_definitions[&quot;</span>
                               <span class="s2">&quot;node.arg] = 0 in place of the assert False. &quot;</span>
                               <span class="s2">&quot;But this case should not occur in general.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;The argument variable was already defined &quot;</span>
                           <span class="s2">&quot;resulting in state.last_definitions containing an &quot;</span>
                           <span class="s2">&quot;entry to this argument. Resolve this by setting &quot;</span>
                           <span class="s2">&quot;state.last_definitions[node.arg] += 1. But this &quot;</span>
                           <span class="s2">&quot;case should not occur in general.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">arg</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_index"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_index">[docs]</a>    <span class="k">def</span> <span class="nf">process_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles the Index node of the ast. The Index node</span>
<span class="sd">            is a `slice` value which appears when a `[]` indexing occurs.</span>
<span class="sd">            For example: x[Real], a[0], etc. So, the `value` of the index can</span>
<span class="sd">            either be an ast.Name (x[Real]) or an ast.Num (a[0]), or any</span>
<span class="sd">            other ast type. So, we forward the `value` to its respective ast</span>
<span class="sd">            handler.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_num"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_num">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">process_num</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles the ast.Num of the ast tree. This node only</span>
<span class="sd">            contains a numeric value in its body. For example: Num(n=0),</span>
<span class="sd">            Num(n=17.27), etc. So, we return the numeric value in a</span>
<span class="sd">            &lt;function_assign_body_literal_spec&gt; form.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: According to new specification, the following structure</span>
        <span class="c1">#  should be used: {&quot;type&quot;: &quot;literal, &quot;value&quot;: {&quot;dtype&quot;: &lt;type&gt;,</span>
        <span class="c1">#  &quot;value&quot;: &lt;value&gt;}}. Confirm with Clay.</span>
        <span class="n">data_type</span> <span class="o">=</span> <span class="n">ANNOTATE_MAP</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data_type</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="n">data_type</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">n</span><span class="p">}</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="n">f</span><span class="s2">&quot;Unidentified data type of variable: </span><span class="si">{node.n}</span><span class="s2">&quot;</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_list_ast"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_list_ast">[docs]</a>    <span class="k">def</span> <span class="nf">process_list_ast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles ast.List which represents Python lists. The</span>
<span class="sd">            ast.List has an `elts` element which is a list of all the elements</span>
<span class="sd">            of the list. This is most notably encountered in annotated</span>
<span class="sd">            assignment of variables to [None] (Example: day: List[int] = [</span>
<span class="sd">            None]). This is handled by calling `gen_grfn` on every element of</span>
<span class="sd">            the list i.e. every element of `elts`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Will using element[0] work every time? Test on cases like</span>
        <span class="c1">#  [x+y, 4,5]. Here `x+y` should result in a [{spec_for_a},</span>
        <span class="c1">#  {spec_for_b}] format. So, element[0] will only take {spec_for_a}.</span>
        <span class="c1">#  Such cases not encountered yet but can occur.</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">list_element</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;List&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">list_element</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">elts</span>
            <span class="p">]</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">elements</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">[{</span><span class="s2">&quot;list&quot;</span><span class="p">:</span> <span class="n">elements</span><span class="p">}]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_str"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_str">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">process_str</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles the ast.Str of the ast tree. This node only</span>
<span class="sd">            contains a string value in its body. For example: Str(s=&#39;lorem&#39;),</span>
<span class="sd">            Str(s=&#39;Estimate: &#39;), etc. So, we return the string value in a</span>
<span class="sd">            &lt;function_assign_body_literal_spec&gt; form where the dtype is a</span>
<span class="sd">            string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: According to new specification, the following structure</span>
        <span class="c1">#  should be used: {&quot;type&quot;: &quot;literal, &quot;value&quot;: {&quot;dtype&quot;: &lt;type&gt;,</span>
        <span class="c1">#  &quot;value&quot;: &lt;value&gt;}}. Confirm with Clay.</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">s</span><span class="p">}</span>
        <span class="p">]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_for"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_for">[docs]</a>    <span class="k">def</span> <span class="nf">process_for</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="n">scope_path</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">scope_path</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scope_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">scope_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;_TOP&quot;</span><span class="p">)</span>
        <span class="n">scope_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;loop&quot;</span><span class="p">)</span>

        <span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
            <span class="n">last_definitions</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="n">next_definitions</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="n">last_definition_default</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">last_definition_default</span><span class="p">,</span>
            <span class="n">function_name</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">function_name</span><span class="p">,</span>
            <span class="n">variable_types</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="n">lambda_strings</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">lambda_strings</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="n">scope_path</span><span class="o">=</span><span class="n">scope_path</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;for&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">For2PyError</span><span class="p">(</span><span class="s2">&quot;For/Else in for not supported.&quot;</span><span class="p">)</span>

        <span class="n">indexVar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;for&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexVar</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="s2">&quot;var&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">indexVar</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">For2PyError</span><span class="p">(</span><span class="s2">&quot;Only one index variable is supported.&quot;</span><span class="p">)</span>
        <span class="n">indexName</span> <span class="o">=</span> <span class="n">indexVar</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
        <span class="n">loopIter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">iter</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;for&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">loopIter</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span>
                <span class="ow">or</span> <span class="s2">&quot;call&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">loopIter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="ow">or</span> <span class="n">loopIter</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;function&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;range&quot;</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="n">For2PyError</span><span class="p">(</span><span class="s2">&quot;Can only iterate over a range.&quot;</span><span class="p">)</span>

        <span class="n">rangeCall</span> <span class="o">=</span> <span class="n">loopIter</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;call&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">2</span>
                <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span>
                <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span>
                <span class="ow">or</span> <span class="p">(</span>
                <span class="s2">&quot;type&quot;</span> <span class="ow">in</span> <span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="ow">and</span> <span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;literal&quot;</span>
        <span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span>
                <span class="s2">&quot;type&quot;</span> <span class="ow">in</span> <span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="ow">and</span> <span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;literal&quot;</span>
        <span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="n">For2PyError</span><span class="p">(</span><span class="s2">&quot;Can only iterate over a constant range.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">iterationRange</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;start&quot;</span><span class="p">:</span> <span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                <span class="s2">&quot;end&quot;</span><span class="p">:</span> <span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
            <span class="p">}</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">iterationRange</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;start&quot;</span><span class="p">:</span> <span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                <span class="s2">&quot;end&quot;</span><span class="p">:</span> <span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                <span class="s2">&quot;step&quot;</span><span class="p">:</span> <span class="n">rangeCall</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
            <span class="p">}</span>

        <span class="n">loopLastDef</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">loopState</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
            <span class="n">last_definitions</span><span class="o">=</span><span class="n">loopLastDef</span><span class="p">,</span> <span class="n">next_definitions</span><span class="o">=</span><span class="p">{},</span>
            <span class="n">last_definition_default</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="n">loopState</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">indexName</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">loop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">loopState</span><span class="p">,</span> <span class="s2">&quot;for&quot;</span><span class="p">)</span>

        <span class="n">loopBody</span><span class="p">,</span> <span class="n">loopFns</span><span class="p">,</span> <span class="n">iden_spec</span> <span class="o">=</span> <span class="n">get_body_and_functions</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>

        <span class="c1"># If loopLastDef[x] == 0, this means that the variable was not</span>
        <span class="c1"># declared before the loop and is being declared/defined within</span>
        <span class="c1"># the loop. So we need to remove that from the variable_list</span>
        <span class="n">variable_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">loopLastDef</span> <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">indexName</span> <span class="ow">and</span>
                                                    <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span>
                                                        <span class="n">x</span><span class="p">]</span> <span class="o">!=</span>
                                                    <span class="mi">0</span><span class="p">)]</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">variable</span><span class="p">,</span> <span class="s2">&quot;domain&quot;</span><span class="p">:</span> <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span><span class="n">variable</span><span class="p">]}</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">variable_list</span>
        <span class="p">]</span>

        <span class="c1"># Removing the indexing of the loop index variable from the loopName</span>
        <span class="c1"># loopName = get_function_name(</span>
        <span class="c1">#     f&quot;{state.function_name}__loop_plate__{</span>
        <span class="c1">#     indexName}&quot;, {}</span>
        <span class="c1"># )</span>

        <span class="n">loopName</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">function_name</span> <span class="o">+</span> <span class="s2">&quot;__loop_plate__&quot;</span> <span class="o">+</span> <span class="n">indexName</span>

        <span class="n">loopFn</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">loopName</span><span class="p">,</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;loop_plate&quot;</span><span class="p">,</span>
            <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="n">variables</span><span class="p">,</span>
            <span class="s2">&quot;index_variable&quot;</span><span class="p">:</span> <span class="n">indexName</span><span class="p">,</span>
            <span class="s2">&quot;index_iteration_range&quot;</span><span class="p">:</span> <span class="n">iterationRange</span><span class="p">,</span>
            <span class="s2">&quot;body&quot;</span><span class="p">:</span> <span class="n">loopBody</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">id_specList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_identifier_spec</span><span class="p">(</span>
            <span class="n">loopName</span><span class="p">,</span> <span class="n">indexName</span><span class="p">,</span> <span class="p">{},</span> <span class="n">state</span>
        <span class="p">)</span>
        <span class="n">loopCall</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">loopName</span><span class="p">,</span>
            <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">variable</span><span class="p">,</span>
                    <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">loopState</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
                <span class="p">}</span>
                <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">variable_list</span>
            <span class="p">],</span>
            <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="p">{}</span>
        <span class="p">}</span>

        <span class="n">pgm</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;functions&quot;</span><span class="p">:</span> <span class="n">loopFns</span> <span class="o">+</span> <span class="p">[</span><span class="n">loopFn</span><span class="p">],</span>
            <span class="s2">&quot;body&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">loopCall</span><span class="p">],</span>
            <span class="s2">&quot;identifiers&quot;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">id_spec</span> <span class="ow">in</span> <span class="n">id_specList</span><span class="p">:</span>
            <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;identifiers&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_spec</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">pgm</span><span class="p">]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_if"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_if">[docs]</a>    <span class="k">def</span> <span class="nf">process_if</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles the ast.IF node of the AST. It goes through</span>
<span class="sd">            the IF body and generates the `decision` and `condition` type of</span>
<span class="sd">            the `&lt;function_assign_def&gt;`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scope_path</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">scope_path</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scope_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">scope_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;_TOP&quot;</span><span class="p">)</span>
        <span class="n">scope_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;if&quot;</span><span class="p">)</span>

        <span class="n">state</span><span class="o">.</span><span class="n">scope_path</span> <span class="o">=</span> <span class="n">scope_path</span>

        <span class="c1"># If a ast.If is present within another ast.If, the call_source will</span>
        <span class="c1"># be `if`. This can happen in two cases:</span>
        <span class="c1"># 1. A nested if condition.</span>
        <span class="c1"># 2. A Fortran if-else condition which when translated to Python is</span>
        <span class="c1"># converted into a else: if .. condition (See PETASCE_simple.py for</span>
        <span class="c1"># example).</span>
        <span class="k">if</span> <span class="n">call_source</span> <span class="o">==</span> <span class="s2">&quot;if&quot;</span><span class="p">:</span>
            <span class="n">grfn</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;functions&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;body&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;identifiers&quot;</span><span class="p">:</span> <span class="p">[]}</span>

            <span class="n">condition_sources</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">test</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;if&quot;</span><span class="p">)</span>

            <span class="n">start_definitions</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">if_definitions</span> <span class="o">=</span> <span class="n">start_definitions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">else_definitions</span> <span class="o">=</span> <span class="n">start_definitions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">if_state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">last_definitions</span><span class="o">=</span><span class="n">if_definitions</span><span class="p">)</span>
            <span class="n">else_state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">last_definitions</span><span class="o">=</span><span class="n">else_definitions</span><span class="p">)</span>
            <span class="n">if_grfn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">if_state</span><span class="p">,</span> <span class="s2">&quot;if&quot;</span><span class="p">)</span>
            <span class="n">else_grfn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">,</span> <span class="n">else_state</span><span class="p">,</span> <span class="s2">&quot;if&quot;</span><span class="p">)</span>

            <span class="n">updated_definitions</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">var</span>
                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">start_definitions</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                    <span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">if_definitions</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                    <span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">else_definitions</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">start_definitions</span>
                   <span class="ow">or</span> <span class="n">if_definitions</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">!=</span> <span class="n">start_definitions</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
                   <span class="ow">or</span> <span class="n">else_definitions</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">!=</span> <span class="n">start_definitions</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
            <span class="p">]</span>

            <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">reduce</span><span class="p">(</span>
                <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]),</span> <span class="p">[[]]</span> <span class="o">+</span> <span class="n">if_grfn</span>
            <span class="p">)</span> <span class="o">+</span> <span class="n">reduce</span><span class="p">((</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]),</span> <span class="p">[[]]</span> <span class="o">+</span> <span class="n">else_grfn</span><span class="p">)</span>

            <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">reduce</span><span class="p">(</span>
                <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]),</span> <span class="p">[[]]</span> <span class="o">+</span> <span class="n">if_grfn</span>
            <span class="p">)</span> <span class="o">+</span> <span class="n">reduce</span><span class="p">((</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]),</span> <span class="p">[[]]</span> <span class="o">+</span> <span class="n">else_grfn</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">elif_grfn</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">grfn</span><span class="p">,</span>
                <span class="n">condition_sources</span><span class="p">,</span>
                <span class="n">node</span><span class="o">.</span><span class="n">test</span><span class="p">,</span>
                <span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="p">,</span>
                <span class="n">node</span><span class="p">,</span>
                <span class="n">updated_definitions</span><span class="p">,</span>
                <span class="n">if_definitions</span><span class="p">,</span>
                <span class="n">state</span><span class="p">,</span>
            <span class="p">]</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">pgm</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;functions&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;body&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;identifiers&quot;</span><span class="p">:</span> <span class="p">[]}</span>

        <span class="n">condSrcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">test</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;if&quot;</span><span class="p">)</span>

        <span class="c1"># Making the index of IF_X_X start from 1 instead of 2</span>
        <span class="n">condNum</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;#cond&quot;</span><span class="p">,</span>
                                             <span class="n">state</span><span class="o">.</span><span class="n">last_definition_default</span>
                                             <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="p">[</span><span class="s2">&quot;#cond&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">condNum</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">condName</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;IF_</span><span class="si">{condNum}</span><span class="s2">&quot;</span>
        <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span><span class="n">condName</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;bool&quot;</span>
        <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">condName</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">function_name</span> <span class="o">=</span> <span class="n">get_function_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function_names</span><span class="p">,</span>
                                          <span class="n">f</span><span class="s2">&quot;</span><span class="si">{state.function_name}</span><span class="s2">__condition__&quot;</span>
                                          <span class="n">f</span><span class="s2">&quot;</span><span class="si">{condName}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="p">{})</span>

        <span class="c1"># The condName is of the form &#39;IF_1&#39; and the index holds the</span>
        <span class="c1"># ordering of the condName. This means that index should increment</span>
        <span class="c1"># of every new &#39;IF&#39; statement. Previously, it was set to set to 0.</span>
        <span class="c1"># But, &#39;function_name&#39; holds the current index of &#39;condName&#39;</span>
        <span class="c1"># So, extract the index from &#39;function_name&#39;.</span>
        <span class="c1"># condOutput = {&quot;variable&quot;: condName, &quot;index&quot;: 0}</span>
        <span class="n">condOutput</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">condName</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">function_name</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])}</span>

        <span class="n">fn</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">function_name</span><span class="p">,</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;condition&quot;</span><span class="p">,</span>
            <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="n">condName</span><span class="p">,</span>
            <span class="s2">&quot;reference&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="p">,</span>
            <span class="s2">&quot;sources&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;variable&quot;</span><span class="p">}</span>
                <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">condSrcs</span>
                <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span>
            <span class="p">],</span>
        <span class="p">}</span>

        <span class="n">id_specList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_identifier_spec</span><span class="p">(</span>
            <span class="n">function_name</span><span class="p">,</span>
            <span class="n">condOutput</span><span class="p">,</span>
            <span class="p">[</span><span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">condSrcs</span> <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">],</span>
            <span class="n">state</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">id_spec</span> <span class="ow">in</span> <span class="n">id_specList</span><span class="p">:</span>
            <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;identifiers&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_spec</span><span class="p">)</span>

        <span class="n">body</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">function_name</span><span class="p">,</span>
            <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="n">condOutput</span><span class="p">,</span>
            <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">condSrcs</span> <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">],</span>
        <span class="p">}</span>

        <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
        <span class="n">lambda_string</span> <span class="o">=</span> <span class="n">genFn</span><span class="p">(</span>
            <span class="n">node</span><span class="o">.</span><span class="n">test</span><span class="p">,</span>
            <span class="n">function_name</span><span class="p">,</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="p">[</span><span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">condSrcs</span> <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">],</span>
            <span class="n">state</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">state</span><span class="o">.</span><span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lambda_string</span><span class="p">)</span>
        <span class="n">startDefs</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ifDefs</span> <span class="o">=</span> <span class="n">startDefs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">elseDefs</span> <span class="o">=</span> <span class="n">startDefs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ifState</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">last_definitions</span><span class="o">=</span><span class="n">ifDefs</span><span class="p">)</span>
        <span class="n">elseState</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">last_definitions</span><span class="o">=</span><span class="n">elseDefs</span><span class="p">)</span>
        <span class="n">ifPgm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">ifState</span><span class="p">,</span> <span class="s2">&quot;if&quot;</span><span class="p">)</span>
        <span class="n">elsePgm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">,</span> <span class="n">elseState</span><span class="p">,</span> <span class="s2">&quot;if&quot;</span><span class="p">)</span>

        <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">reduce</span><span class="p">(</span>
            <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]),</span> <span class="p">[[]]</span> <span class="o">+</span> <span class="n">ifPgm</span>
        <span class="p">)</span> <span class="o">+</span> <span class="n">reduce</span><span class="p">((</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]),</span> <span class="p">[[]]</span> <span class="o">+</span> <span class="n">elsePgm</span><span class="p">)</span>

        <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">reduce</span><span class="p">(</span>
            <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]),</span> <span class="p">[[]]</span> <span class="o">+</span> <span class="n">ifPgm</span>
        <span class="p">)</span> <span class="o">+</span> <span class="n">reduce</span><span class="p">((</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]),</span> <span class="p">[[]]</span> <span class="o">+</span> <span class="n">elsePgm</span><span class="p">)</span>

        <span class="n">updatedDefs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">var</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">startDefs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">ifDefs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">elseDefs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">startDefs</span>
               <span class="ow">or</span> <span class="n">ifDefs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">!=</span> <span class="n">startDefs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
               <span class="ow">or</span> <span class="n">elseDefs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">!=</span> <span class="n">startDefs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
        <span class="p">]</span>

        <span class="n">defVersions</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">key</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">version</span>
                <span class="k">for</span> <span class="n">version</span> <span class="ow">in</span> <span class="p">[</span>
                    <span class="n">startDefs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">),</span>
                    <span class="n">ifDefs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">),</span>
                    <span class="n">elseDefs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">),</span>
                <span class="p">]</span>
                <span class="k">if</span> <span class="n">version</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">updatedDefs</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">updatedDef</span> <span class="ow">in</span> <span class="n">defVersions</span><span class="p">:</span>
            <span class="n">versions</span> <span class="o">=</span> <span class="n">defVersions</span><span class="p">[</span><span class="n">updatedDef</span><span class="p">]</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">condOutput</span><span class="p">,</span>
                    <span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">updatedDef</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">versions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]},</span>
                    <span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">updatedDef</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">versions</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]},</span>
                <span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">versions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
                <span class="k">else</span> <span class="p">[</span>
                    <span class="n">condOutput</span><span class="p">,</span>
                    <span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">updatedDef</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">versions</span><span class="p">[</span><span class="mi">0</span><span class="p">]},</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="n">output</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">updatedDef</span><span class="p">,</span>
                <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">get_next_definition</span><span class="p">(</span>
                    <span class="n">updatedDef</span><span class="p">,</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">,</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="p">,</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">last_definition_default</span><span class="p">,</span>
                <span class="p">),</span>
            <span class="p">}</span>

            <span class="n">function_name</span> <span class="o">=</span> <span class="n">get_function_name</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">function_names</span><span class="p">,</span>
                <span class="n">f</span><span class="s2">&quot;</span><span class="si">{state.function_name}</span><span class="s2">__decision__</span><span class="si">{updatedDef}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">output</span>
            <span class="p">)</span>

            <span class="n">fn</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">function_name</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;decision&quot;</span><span class="p">,</span>
                <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="n">updatedDef</span><span class="p">,</span>
                <span class="s2">&quot;reference&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="p">,</span>
                <span class="s2">&quot;sources&quot;</span><span class="p">:</span> <span class="p">[</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{var[&#39;variable&#39;]}</span><span class="s2">_</span><span class="si">{var[&#39;index&#39;]}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;variable&quot;</span><span class="p">,</span>
                    <span class="p">}</span>
                    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">inputs</span>
                <span class="p">],</span>
            <span class="p">}</span>

            <span class="c1"># Check for buggy __decision__ tag containing of only IF_ blocks</span>
            <span class="c1"># More information required on how __decision__ tags are made</span>
            <span class="c1"># This seems to be in development phase and documentation is</span>
            <span class="c1"># missing from the GrFN spec as well. Actual removal (or not)</span>
            <span class="c1"># of this tag depends on further information about this</span>

            <span class="k">if</span> <span class="s2">&quot;IF_&quot;</span> <span class="ow">in</span> <span class="n">updatedDef</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;IF_&quot;</span> <span class="ow">in</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]:</span>
                        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
                    <span class="k">continue</span>

            <span class="n">body</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">function_name</span><span class="p">,</span> <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="n">output</span><span class="p">,</span> <span class="s2">&quot;input&quot;</span><span class="p">:</span>
                <span class="n">inputs</span><span class="p">}</span>

            <span class="n">id_specList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_identifier_spec</span><span class="p">(</span>
                <span class="n">function_name</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">state</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">id_spec</span> <span class="ow">in</span> <span class="n">id_specList</span><span class="p">:</span>
                <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;identifiers&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_spec</span><span class="p">)</span>

            <span class="n">lambda_string</span> <span class="o">=</span> <span class="n">genFn</span><span class="p">(</span>
                <span class="n">node</span><span class="p">,</span>
                <span class="n">function_name</span><span class="p">,</span>
                <span class="n">updatedDef</span><span class="p">,</span>
                <span class="p">[</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{src[&#39;variable&#39;]}</span><span class="s2">_</span><span class="si">{src[&#39;index&#39;]}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">],</span>
                <span class="n">state</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">state</span><span class="o">.</span><span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lambda_string</span><span class="p">)</span>

            <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>

        <span class="c1"># Previous ELIF Block is filled??</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elif_grfn</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

            <span class="n">condSrcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elif_grfn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elif_grfn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;functions&quot;</span><span class="p">]:</span>
                <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elif_grfn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;body&quot;</span><span class="p">]:</span>
                <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

            <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="p">[</span><span class="s2">&quot;#cond&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">condNum</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="n">condName</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;IF_</span><span class="si">{condNum}</span><span class="s2">&quot;</span>
            <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span><span class="n">condName</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;bool&quot;</span>
            <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">[</span><span class="n">condName</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">function_name</span> <span class="o">=</span> <span class="n">get_function_name</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">function_names</span><span class="p">,</span>
                <span class="n">f</span><span class="s2">&quot;</span><span class="si">{state.function_name}</span><span class="s2">__condition__</span><span class="si">{condName}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="p">{}</span>
            <span class="p">)</span>
            <span class="n">condOutput</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">condName</span><span class="p">,</span>
                <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">function_name</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">}</span>

            <span class="n">fn</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">function_name</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;condition&quot;</span><span class="p">,</span>
                <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="n">condName</span><span class="p">,</span>
                <span class="s2">&quot;reference&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">elif_grfn</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                <span class="s2">&quot;sources&quot;</span><span class="p">:</span> <span class="p">[</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span>
                        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;variable&quot;</span><span class="p">,</span>
                    <span class="p">}</span>
                    <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">condSrcs</span>
                    <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span>
                <span class="p">],</span>
            <span class="p">}</span>

            <span class="n">id_specList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_identifier_spec</span><span class="p">(</span>
                <span class="n">function_name</span><span class="p">,</span>
                <span class="n">condOutput</span><span class="p">,</span>
                <span class="p">[</span><span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">condSrcs</span> <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">],</span>
                <span class="n">state</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">id_spec</span> <span class="ow">in</span> <span class="n">id_specList</span><span class="p">:</span>
                <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;identifiers&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_spec</span><span class="p">)</span>

            <span class="n">body</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">function_name</span><span class="p">,</span>
                <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="n">condOutput</span><span class="p">,</span>
                <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="p">[</span>
                    <span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">condSrcs</span> <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span>
                <span class="p">],</span>
            <span class="p">}</span>
            <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>

            <span class="n">lambda_string</span> <span class="o">=</span> <span class="n">genFn</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">elif_grfn</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">function_name</span><span class="p">,</span>
                <span class="kc">None</span><span class="p">,</span>
                <span class="p">[</span>
                    <span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">condSrcs</span>
                    <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span>
                <span class="p">],</span>
                <span class="n">state</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">state</span><span class="o">.</span><span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lambda_string</span><span class="p">)</span>

            <span class="n">startDefs</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">ifDefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elif_grfn</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
            <span class="n">elseDefs</span> <span class="o">=</span> <span class="n">startDefs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="n">updatedDefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elif_grfn</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>

            <span class="n">defVersions</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">key</span><span class="p">:</span> <span class="p">[</span>
                    <span class="n">version</span>
                    <span class="k">for</span> <span class="n">version</span> <span class="ow">in</span> <span class="p">[</span>
                        <span class="n">startDefs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">),</span>
                        <span class="n">ifDefs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">),</span>
                        <span class="n">elseDefs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">),</span>
                    <span class="p">]</span>
                    <span class="k">if</span> <span class="n">version</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="p">]</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">updatedDefs</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="n">updatedDef</span> <span class="ow">in</span> <span class="n">defVersions</span><span class="p">:</span>
                <span class="n">versions</span> <span class="o">=</span> <span class="n">defVersions</span><span class="p">[</span><span class="n">updatedDef</span><span class="p">]</span>
                <span class="n">inputs</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">condOutput</span><span class="p">,</span>
                        <span class="p">{</span>
                            <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">updatedDef</span><span class="p">,</span>
                            <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">versions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                        <span class="p">},</span>
                        <span class="p">{</span>
                            <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">updatedDef</span><span class="p">,</span>
                            <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">versions</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>
                        <span class="p">},</span>
                    <span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">versions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
                    <span class="k">else</span> <span class="p">[</span>
                        <span class="n">condOutput</span><span class="p">,</span>
                        <span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">updatedDef</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">versions</span><span class="p">[</span><span class="mi">0</span><span class="p">]},</span>
                    <span class="p">]</span>
                <span class="p">)</span>

                <span class="n">output</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">updatedDef</span><span class="p">,</span>
                    <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">get_next_definition</span><span class="p">(</span>
                        <span class="n">updatedDef</span><span class="p">,</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">,</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="p">,</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">last_definition_default</span><span class="p">,</span>
                    <span class="p">),</span>
                <span class="p">}</span>
                <span class="n">function_name</span> <span class="o">=</span> <span class="n">get_function_name</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">function_names</span><span class="p">,</span>
                    <span class="n">f</span><span class="s2">&quot;</span><span class="si">{state.function_name}</span><span class="s2">__decision__</span><span class="si">{updatedDef}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">output</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">fn</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">function_name</span><span class="p">,</span>
                    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;decision&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="n">updatedDef</span><span class="p">,</span>
                    <span class="s2">&quot;reference&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">elif_grfn</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                    <span class="s2">&quot;sources&quot;</span><span class="p">:</span> <span class="p">[</span>
                        <span class="p">{</span>
                            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{var[&#39;variable&#39;]}</span><span class="s2">_</span><span class="si">{var[&#39;index&#39;]}</span><span class="s2">&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;variable&quot;</span><span class="p">,</span>
                        <span class="p">}</span>
                        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">inputs</span>
                    <span class="p">],</span>
                <span class="p">}</span>

                <span class="c1"># Check for buggy __decision__ tag containing of only</span>
                <span class="c1"># IF_ blocks. More information required on how</span>
                <span class="c1"># __decision__ tags are made.</span>
                <span class="c1"># This seems to be in development phase and documentation is</span>
                <span class="c1"># missing from the GrFN spec as well. Actual removal</span>
                <span class="c1"># (or not) of this tag depends on further information</span>
                <span class="c1"># about this</span>

                <span class="k">if</span> <span class="s2">&quot;IF_&quot;</span> <span class="ow">in</span> <span class="n">updatedDef</span><span class="p">:</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
                        <span class="k">if</span> <span class="s2">&quot;IF_&quot;</span> <span class="ow">in</span> <span class="n">var</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]:</span>
                            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
                        <span class="k">continue</span>

                <span class="n">body</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">function_name</span><span class="p">,</span>
                    <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="n">output</span><span class="p">,</span>
                    <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="n">inputs</span><span class="p">,</span>
                <span class="p">}</span>

                <span class="n">id_specList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_identifier_spec</span><span class="p">(</span>
                    <span class="n">function_name</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">state</span>
                <span class="p">)</span>

                <span class="k">for</span> <span class="n">id_spec</span> <span class="ow">in</span> <span class="n">id_specList</span><span class="p">:</span>
                    <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;identifiers&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_spec</span><span class="p">)</span>

                <span class="n">lambda_string</span> <span class="o">=</span> <span class="n">genFn</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">elif_grfn</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
                    <span class="n">function_name</span><span class="p">,</span>
                    <span class="n">updatedDef</span><span class="p">,</span>
                    <span class="p">[</span>
                        <span class="n">f</span><span class="s2">&quot;</span><span class="si">{src[&#39;variable&#39;]}</span><span class="s2">_</span><span class="si">{src[&#39;index&#39;]}</span><span class="s2">&quot;</span>
                        <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">inputs</span>
                    <span class="p">],</span>
                    <span class="n">state</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">state</span><span class="o">.</span><span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lambda_string</span><span class="p">)</span>

                <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
                <span class="n">pgm</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">elif_grfn</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">pgm</span><span class="p">]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_unary_operation"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_unary_operation">[docs]</a>    <span class="k">def</span> <span class="nf">process_unary_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function processes unary operations in Python represented by</span>
<span class="sd">            ast.UnaryOp. This node has an `op` key which contains the</span>
<span class="sd">            operation (e.g. USub for -, UAdd for +, Not, Invert) and an</span>
<span class="sd">            `operand` key which contains the operand of the operation. This</span>
<span class="sd">            operand can in itself be any Python object (Number, Function</span>
<span class="sd">            call, Binary Operation, Unary Operation, etc. So, iteratively</span>
<span class="sd">            call the respective ast handler for the operand.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;unaryop&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_binary_operation"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_binary_operation">[docs]</a>    <span class="k">def</span> <span class="nf">process_binary_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles binary operations i.e. ast.BinOp</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If both the left and right operands are numbers (ast.Num), we can</span>
        <span class="c1"># simply perform the respective operation on these two numbers and</span>
        <span class="c1"># represent this computation in a GrFN spec.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Num</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Num</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">BINOPS</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">BINOPS</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">)](</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
                    <span class="n">data_type</span> <span class="o">=</span> <span class="n">ANNOTATE_MAP</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">data_type</span><span class="p">:</span>
                        <span class="k">return</span> <span class="p">[</span>
                            <span class="p">{</span>
                                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="n">data_type</span><span class="p">,</span>
                                <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">val</span><span class="p">,</span>
                            <span class="p">}</span>
                        <span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="n">f</span><span class="s2">&quot;Unidentified data type of: </span><span class="si">{val}</span><span class="s2">&quot;</span>
            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;Both operands are numbers but no operator &quot;</span>
                           <span class="s2">&quot;available to handle their computation. Either add &quot;</span>
                           <span class="s2">&quot;a handler if possible or remove this assert and &quot;</span>
                           <span class="s2">&quot;allow the code below to handle such cases.&quot;</span><span class="p">)</span>

        <span class="c1"># If the operands are anything other than numbers (ast.Str,</span>
        <span class="c1"># ast.BinOp, etc), call `gen_grfn` on each side so their respective</span>
        <span class="c1"># ast handlers will process them and return a [{grfn_spec}, ..] form</span>
        <span class="c1"># for each side. Add these two sides together to give a single [{</span>
        <span class="c1"># grfn_spec}, ...] form.</span>
        <span class="n">operation_grfn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;binop&quot;</span><span class="p">)</span> \
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;binop&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">operation_grfn</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_boolean_operation"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_boolean_operation">[docs]</a>    <span class="k">def</span> <span class="nf">process_boolean_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function will process the ast.BoolOp node that handles</span>
<span class="sd">            boolean operations i.e. AND, OR, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: No example of this to test on. This looks like deprecated</span>
        <span class="c1">#  format. Will need to be rechecked.</span>
        <span class="n">grfn_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">operation</span> <span class="o">=</span> <span class="p">{</span><span class="n">ast</span><span class="o">.</span><span class="n">And</span><span class="p">:</span> <span class="s2">&quot;and&quot;</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Or</span><span class="p">:</span> <span class="s2">&quot;or&quot;</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">operation</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
                <span class="n">grfn_list</span><span class="o">.</span><span class="n">append</span><span class="p">([{</span><span class="s2">&quot;boolean_operation&quot;</span><span class="p">:</span> <span class="n">operation</span><span class="p">[</span><span class="n">key</span><span class="p">]}])</span>

        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
            <span class="n">grfn_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;boolop&quot;</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">grfn_list</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_unnecessary_types"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_unnecessary_types">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">process_unnecessary_types</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles various ast tags which are unnecessary and</span>
<span class="sd">            need not be handled since we do not require to parse them</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node_name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">:]</span>
        <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="n">f</span><span class="s2">&quot;Found </span><span class="si">{node_name}</span><span class="s2">, which should be unnecessary&quot;</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_expression"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_expression">[docs]</a>    <span class="k">def</span> <span class="nf">process_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles the ast.Expr node i.e. the expression node.</span>
<span class="sd">            This node appears on function calls such as when calling a</span>
<span class="sd">            function, calling print(), etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">expressions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;expr&quot;</span><span class="p">)</span>
        <span class="n">grfn</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;functions&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;body&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;identifiers&quot;</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;call&quot;</span> <span class="ow">in</span> <span class="n">expr</span><span class="p">:</span>
                <span class="n">call</span> <span class="o">=</span> <span class="n">expr</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">]</span>
                <span class="n">body</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="n">call</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="p">{},</span>
                    <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="p">[],</span>
                <span class="p">}</span>
                <span class="c1"># If the call is to the write() function of a file handle,</span>
                <span class="c1"># bypass this expression as I/O is not handled currently</span>
                <span class="c1"># TODO: Will need to be handled once I/O is handled</span>
                <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;file_\d+\.write&quot;</span><span class="p">,</span> <span class="n">body</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">]):</span>
                    <span class="k">return</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">call</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># TODO: Only variables are represented in function</span>
                        <span class="c1">#  arguments. But a function can have strings as</span>
                        <span class="c1">#  arguments as well. Do we add that?</span>
                        <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="n">body</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">For2PyError</span><span class="p">(</span>
                            <span class="s2">&quot;Only 1 input per argument supported right now.&quot;</span>
                        <span class="p">)</span>
                <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">For2PyError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Unsupported expr: </span><span class="si">{expr}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">grfn</span><span class="p">]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_compare"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_compare">[docs]</a>    <span class="k">def</span> <span class="nf">process_compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles ast.Compare i.e. the comparator tag which</span>
<span class="sd">            appears on logical comparison i.e. ==, &lt;, &gt;, &lt;=, etc. This</span>
<span class="sd">            generally occurs within an `if` statement but can occur elsewhere</span>
<span class="sd">            as well.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;compare&quot;</span><span class="p">)</span> \
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">comparators</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;compare&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_subscript"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_subscript">[docs]</a>    <span class="k">def</span> <span class="nf">process_subscript</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles the ast.Subscript i.e. subscript tag of the</span>
<span class="sd">            ast. This tag appears on variable names that are indexed i.e.</span>
<span class="sd">            x[0], y[5], var[float], etc. Subscript nodes will have a `slice`</span>
<span class="sd">            tag which gives a information inside the [] of the call.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The value inside the [] should be a number for now.</span>
        <span class="c1"># TODO: Remove this and handle further for implementations of arrays,</span>
        <span class="c1">#  reference of dictionary item, etc</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">slice</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Num</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">For2PyError</span><span class="p">(</span><span class="s2">&quot;can&#39;t handle arrays right now.&quot;</span><span class="p">)</span>

        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;subscript&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">val</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotated_assigned</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Store</span><span class="p">):</span>
                    <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_next_definition</span><span class="p">(</span>
                        <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">,</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="p">,</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">last_definition_default</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="k">elif</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;index&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Store</span><span class="p">):</span>
                    <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_next_definition</span><span class="p">(</span>
                        <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">,</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="p">,</span>
                        <span class="n">state</span><span class="o">.</span><span class="n">last_definition_default</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">annotated_assigned</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">annotated_assigned</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;No variable name found for subscript node.&quot;</span>

        <span class="k">return</span> <span class="n">val</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_name"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_name">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">process_name</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles the ast.Name node of the AST. This node</span>
<span class="sd">            represents any variable in the code.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Currently, bypassing any `i_g_n_o_r_e___m_e__` variables which are</span>
        <span class="c1"># used for comment extraction.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;i_g_n_o_r_e___m_e__.*&#39;</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">):</span>
            <span class="n">last_definition</span> <span class="o">=</span> <span class="n">get_last_definition</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                                                  <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">,</span>
                                                  <span class="n">state</span><span class="o">.</span><span class="n">last_definition_default</span><span class="p">)</span>

            <span class="c1"># Only increment the index of the variable if it is on the RHS of</span>
            <span class="c1"># the assignment/operation i.e. Store(). Also, we don&#39;t increment</span>
            <span class="c1"># it when the operation is an annotated assignment (of the form</span>
            <span class="c1"># max_rain: List[float] = [None])</span>
            <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Store</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">call_source</span> <span class="o">!=</span> <span class="s2">&quot;annassign&quot;</span>
            <span class="p">):</span>
                <span class="n">last_definition</span> <span class="o">=</span> <span class="n">get_next_definition</span><span class="p">(</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">,</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">next_definitions</span><span class="p">,</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">last_definition_default</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;var&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">last_definition</span><span class="p">}}]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_annotated_assign"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_annotated_assign">[docs]</a>    <span class="k">def</span> <span class="nf">process_annotated_assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles annotated assignment operations i.e.</span>
<span class="sd">            ast.AnnAssign. This tag appears when a variable has been assigned</span>
<span class="sd">            with an annotation e.g. x: int = 5, y: List[float] = None, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If the assignment value of a variable is of type List, retrieve the</span>
        <span class="c1"># targets. As of now, the RHS will be a list only during initial</span>
        <span class="c1"># variable definition i.e. day: List[int] = [None]. So, we only</span>
        <span class="c1"># update our data structures that hold the variable type mapping</span>
        <span class="c1"># and annotated variable mappings. Nothing will be added to the</span>
        <span class="c1"># GrFN.</span>
        <span class="c1"># TODO: Will this change once arrays/lists are implemented?</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">List</span><span class="p">):</span>
            <span class="n">targets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;annassign&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
                <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span><span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]]</span> <span class="o">=</span> \
                    <span class="n">get_variable_type</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">annotation</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotated_assigned</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">annotated_assigned</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">sources</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;annassign&quot;</span><span class="p">)</span>
        <span class="n">targets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;annassign&quot;</span><span class="p">)</span>

        <span class="n">grfn</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;functions&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;body&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;identifiers&quot;</span><span class="p">:</span> <span class="p">[]}</span>

        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
            <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span><span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]]</span> <span class="o">=</span> \
                <span class="n">get_variable_type</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">annotation</span><span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">get_function_name</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">function_names</span><span class="p">,</span>
                <span class="n">f</span><span class="s2">&quot;</span><span class="si">{state.function_name}</span><span class="s2">__assign__&quot;</span>
                <span class="n">f</span><span class="s2">&quot;</span><span class="si">{target[&#39;var&#39;][&#39;variable&#39;]}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="p">{},</span>
            <span class="p">)</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_fn_dict</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">sources</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
            <span class="n">body</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_body_dict</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">sources</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">lambda_string</span> <span class="o">=</span> <span class="n">genFn</span><span class="p">(</span>
                    <span class="n">node</span><span class="p">,</span>
                    <span class="n">name</span><span class="p">,</span>
                    <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span>
                    <span class="p">[</span>
                        <span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">sources</span>
                        <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span>
                    <span class="p">],</span>
                    <span class="n">state</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">state</span><span class="o">.</span><span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lambda_string</span><span class="p">)</span>

            <span class="c1"># In the case of assignments of the form: &quot;ud: List[float]&quot;</span>
            <span class="c1"># an assignment function will be created with an empty input</span>
            <span class="c1"># list. Also, the function dictionary will be empty. We do</span>
            <span class="c1"># not want such assignments in the GrFN so check for an empty</span>
            <span class="c1"># &lt;fn&gt; dictionary and return [] if found</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">fn</span><span class="p">[</span><span class="s2">&quot;sources&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">fn</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;dtype&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{sources[0][&#39;value&#39;]}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="p">}</span>

            <span class="k">for</span> <span class="n">id_spec</span> <span class="ow">in</span> <span class="n">body</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;identifiers&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_spec</span><span class="p">)</span>

            <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">grfn</span><span class="p">]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_assign"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_assign">[docs]</a>    <span class="k">def</span> <span class="nf">process_assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles an assignment operation (ast.Assign).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If the scope path is empty, this has to be the top of the program</span>
        <span class="c1"># scope, so start the scope with a `_TOP` string to denote that the</span>
        <span class="c1"># operation lies at the top of the scope.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">scope_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">state</span><span class="o">.</span><span class="n">scope_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;_TOP&quot;</span><span class="p">)</span>

        <span class="c1"># Get the GrFN element of the RHS side of the assignment which are</span>
        <span class="c1"># the variables involved in the assignment operations.</span>
        <span class="n">sources</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;assign&quot;</span><span class="p">)</span>

        <span class="c1"># This reduce function is useful when a single assignment operation</span>
        <span class="c1"># has multiple targets (E.g: a = b = 5). Currently, the translated</span>
        <span class="c1"># python code does not appear in this way and only a single target</span>
        <span class="c1"># will be present.</span>
        <span class="n">targets</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span>
            <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;assign&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">targets</span>
            <span class="p">],</span>
        <span class="p">)</span>

        <span class="n">grfn</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;functions&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;body&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;identifiers&quot;</span><span class="p">:</span> <span class="p">[]}</span>

        <span class="c1"># Again as above, only a single target appears in current version.</span>
        <span class="c1"># The for loop seems unnecessary but will be required when multiple</span>
        <span class="c1"># targets start appearing.</span>
        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
            <span class="c1"># If the target is a list of variables, the grfn notation for the</span>
            <span class="c1"># target will be a list of variable names i.e. &quot;[a, b, c]&quot;</span>
            <span class="c1"># TODO: This does not seem right. Discuss with Clay and Paul</span>
            <span class="c1">#  about what a proper notation for this would be</span>
            <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;list&quot;</span><span class="p">):</span>
                <span class="n">targets</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;list&quot;</span><span class="p">]]</span>
                <span class="p">)</span>
                <span class="n">target</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;var&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">targets</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}}</span>

            <span class="c1"># Check whether this is an alias assignment i.e. of the form</span>
            <span class="c1"># y=x where y is now the alias of variable x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_alias</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">sources</span><span class="p">)</span>

            <span class="n">name</span> <span class="o">=</span> <span class="n">get_function_name</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">function_names</span><span class="p">,</span>
                <span class="n">f</span><span class="s2">&quot;</span><span class="si">{state.function_name}</span><span class="s2">__assign__&quot;</span>
                <span class="n">f</span><span class="s2">&quot;</span><span class="si">{target[&#39;var&#39;][&#39;variable&#39;]}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">target</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_fn_dict</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">sources</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>
            <span class="n">body</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_body_dict</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">sources</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

            <span class="n">source_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_source_list_dict</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span>

            <span class="n">lambda_string</span> <span class="o">=</span> <span class="n">genFn</span><span class="p">(</span>
                <span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span> <span class="n">source_list</span><span class="p">,</span> <span class="n">state</span>
            <span class="p">)</span>
            <span class="n">state</span><span class="o">.</span><span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lambda_string</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">fn</span><span class="p">[</span><span class="s2">&quot;sources&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;list&quot;</span><span class="p">):</span>
                    <span class="n">dtypes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;list&quot;</span><span class="p">]:</span>
                        <span class="n">dtypes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s2">&quot;dtype&quot;</span><span class="p">])</span>
                        <span class="n">value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">])</span>
                    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dtypes</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;call&quot;</span><span class="p">)</span> <span class="ow">and</span> \
                        <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;function&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Float32&quot;</span><span class="p">:</span>
                    <span class="n">dtype</span> <span class="o">=</span> <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;inputs&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;dtype&quot;</span><span class="p">]</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{sources[0][&#39;call&#39;][&#39;inputs&#39;][0][0][&#39;value&#39;]}</span><span class="s2">&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dtype</span> <span class="o">=</span> <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;dtype&quot;</span><span class="p">]</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{sources[0][&#39;value&#39;]}</span><span class="s2">&quot;</span>
                <span class="n">fn</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="n">dtype</span><span class="p">,</span>
                    <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">value</span><span class="p">,</span>
                <span class="p">}</span>

            <span class="k">for</span> <span class="n">id_spec</span> <span class="ow">in</span> <span class="n">body</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;identifiers&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_spec</span><span class="p">)</span>

            <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">grfn</span><span class="p">]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_tuple"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_tuple">[docs]</a>    <span class="k">def</span> <span class="nf">process_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles the ast.Tuple node of the AST. This handled</span>
<span class="sd">            in the same way `process_list_ast` is handled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">list_element</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;ctx&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">list_element</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">elts</span>
            <span class="p">]</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="n">elements</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">[{</span><span class="s2">&quot;list&quot;</span><span class="p">:</span> <span class="n">elements</span><span class="p">}]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_call"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_call">[docs]</a>    <span class="k">def</span> <span class="nf">process_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles the ast.Call node of the AST. This node</span>
<span class="sd">            denotes the call to a function. The body contains of the function</span>
<span class="sd">            name and its arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if the call is in the form of &lt;module&gt;.&lt;function&gt; (E.g.</span>
        <span class="c1"># math.exp, math.cos, etc). The `module` part here is captured by the</span>
        <span class="c1"># attribute tag.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Attribute</span><span class="p">):</span>
            <span class="c1"># Check if there is a &lt;sys&gt; call. Bypass it if exists.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Attribute</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="n">node</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="s2">&quot;sys&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>
            <span class="n">function_node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">func</span>
            <span class="n">module</span> <span class="o">=</span> <span class="n">function_node</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">id</span>
            <span class="n">function_name</span> <span class="o">=</span> <span class="n">function_node</span><span class="o">.</span><span class="n">attr</span>
            <span class="n">function_name</span> <span class="o">=</span> <span class="n">module</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">function_name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">function_name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">id</span>

        <span class="n">inputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="n">argument</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;call&quot;</span><span class="p">)</span>
            <span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">argument</span><span class="p">)</span>

        <span class="n">call</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;call&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="n">function_name</span><span class="p">,</span> <span class="s2">&quot;inputs&quot;</span><span class="p">:</span> <span class="n">inputs</span><span class="p">}}</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">call</span><span class="p">]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_module"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_module">[docs]</a>    <span class="k">def</span> <span class="nf">process_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function handles the ast.Module node in the AST. The module</span>
<span class="sd">            node is the starting point of the AST and its body consists of</span>
<span class="sd">            the entire ast of the python code.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grfn_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cur</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">:</span>
            <span class="n">grfn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;module&quot;</span><span class="p">)</span>
            <span class="n">grfn_list</span> <span class="o">+=</span> <span class="n">grfn</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">merge_dictionary</span><span class="p">(</span><span class="n">grfn_list</span><span class="p">)]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_attribute"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_attribute">[docs]</a>    <span class="k">def</span> <span class="nf">process_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Handle Attributes: This is a fix on `feature_save` branch to</span>
<span class="sd">            bypass the SAVE statement feature where a SAVEd variable is</span>
<span class="sd">            referenced as &lt;function_name&gt;.&lt;variable_name&gt;. So the code below</span>
<span class="sd">            only returns the &lt;variable_name&gt; which is stored under</span>
<span class="sd">            `node.attr`. The `node.id` stores the &lt;function_name&gt; which is</span>
<span class="sd">            being ignored.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># When a computations float value is extracted using the Float32</span>
        <span class="c1"># class&#39;s _val method, an ast.Attribute will be present</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;_val&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO: This section of the code should be the same as</span>
            <span class="c1">#  `process_name`. Verify this.</span>
            <span class="n">last_definition</span> <span class="o">=</span> <span class="n">get_last_definition</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">attr</span><span class="p">,</span>
                                                  <span class="n">state</span><span class="o">.</span><span class="n">last_definitions</span><span class="p">,</span>
                                                  <span class="n">state</span><span class="o">.</span><span class="n">last_definition_default</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;var&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">attr</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">last_definition</span><span class="p">}}]</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_ast"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_ast">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">process_ast</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="n">f</span><span class="s2">&quot;No handler for AST.</span><span class="si">{node.__class__.__name__}</span><span class="s2"> in gen_grfn, &quot;</span>
            <span class="n">f</span><span class="s2">&quot;fields: </span><span class="si">{node._fields}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_load"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_load">[docs]</a>    <span class="k">def</span> <span class="nf">process_load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">For2PyError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Found ast.Load, which should not happen. &quot;</span>
                          <span class="n">f</span><span class="s2">&quot;From source: </span><span class="si">{call_source}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_store"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_store">[docs]</a>    <span class="k">def</span> <span class="nf">process_store</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">call_source</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">For2PyError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Found ast.Store, which should not happen. &quot;</span>
                          <span class="n">f</span><span class="s2">&quot;From source: </span><span class="si">{call_source}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="GrFNGenerator.process_nomatch"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.process_nomatch">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">process_nomatch</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="n">f</span><span class="s2">&quot;No handler for </span><span class="si">{node.__class__.__name__}</span><span class="s2"> in gen_grfn, &quot;</span>
            <span class="n">f</span><span class="s2">&quot;value: {str(node)}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>

    <span class="c1"># This function checks whether an assignment is an alias created. An alias</span>
    <span class="c1"># is created when an assignment of the form y=x happens such that y is now</span>
    <span class="c1"># an alias of x because it is an exact copy of x. If it is an alias</span>
    <span class="c1"># assignment, the dictionary alias_mapper will get populated.</span>
<div class="viewcode-block" id="GrFNGenerator.check_alias"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.check_alias">[docs]</a>    <span class="k">def</span> <span class="nf">check_alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">sources</span><span class="p">):</span>
        <span class="n">target_index</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;index&quot;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;var&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_mapper</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">target_index</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alias_mapper</span><span class="p">[</span><span class="n">target_index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
                    <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;index&quot;</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alias_mapper</span><span class="p">[</span><span class="n">target_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
                    <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;index&quot;</span><span class="p">])</span>
                <span class="p">]</span></div>

<div class="viewcode-block" id="GrFNGenerator.make_iden_dict"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.make_iden_dict">[docs]</a>    <span class="k">def</span> <span class="nf">make_iden_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">targets</span><span class="p">,</span> <span class="n">scope_path</span><span class="p">,</span> <span class="n">holder</span><span class="p">):</span>
        <span class="c1"># Check for aliases</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">aliases</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_mapper</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">targets</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">targets</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]),</span> <span class="s2">&quot;None&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">aliases</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_mapper</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="s2">&quot;None&quot;</span><span class="p">)</span>

        <span class="c1"># First, check whether the information is from a variable or a</span>
        <span class="c1"># holder(assign, loop, if, etc). Assign the base_name accordingly</span>

        <span class="k">if</span> <span class="n">holder</span> <span class="o">==</span> <span class="s2">&quot;body&quot;</span><span class="p">:</span>
            <span class="c1"># If we are making the identifier specification of a body holder,</span>
            <span class="c1"># the base_name will be the holder</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">base_name</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">name</span>
                    <span class="o">+</span> <span class="s2">&quot;$&quot;</span>
                    <span class="o">+</span> <span class="n">targets</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
                    <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">targets</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">base_name</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;$&quot;</span> <span class="o">+</span> <span class="n">targets</span>
            <span class="n">gensyms_tag</span> <span class="o">=</span> <span class="s2">&quot;h&quot;</span>

        <span class="k">elif</span> <span class="n">holder</span> <span class="o">==</span> <span class="s2">&quot;variable&quot;</span><span class="p">:</span>
            <span class="c1"># The base name will just be the name of the identifier</span>
            <span class="n">base_name</span> <span class="o">=</span> <span class="n">targets</span>
            <span class="n">gensyms_tag</span> <span class="o">=</span> <span class="s2">&quot;v&quot;</span>

        <span class="c1"># The name space should get the entire directory scope of the fortran</span>
        <span class="c1"># file under which it is defined. For PETASCE.for, all modules are</span>
        <span class="c1"># defined in the same fortran file so the namespace will be the same</span>
        <span class="c1"># for all identifiers</span>

        <span class="c1"># TODO handle multiple file namespaces that handle multiple fortran</span>
        <span class="c1">#  file namespacing</span>

        <span class="c1"># TODO Is the namespace path for the python intermediates or the</span>
        <span class="c1">#  original FORTRAN code? Currently, it captures the intermediate</span>
        <span class="c1">#  python file&#39;s path</span>
        <span class="n">name_space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode_mapper</span><span class="p">[</span><span class="s2">&quot;file_name&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
        <span class="n">name_space</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">name_space</span><span class="p">)</span>

        <span class="c1"># The scope captures the scope within the file where it exists. The</span>
        <span class="c1"># context of modules can be implemented here.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scope_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">scope_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;_TOP&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">scope_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;_TOP&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">scope_path</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">scope_path</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;_TOP&quot;</span><span class="p">)</span>
        <span class="n">scope_path</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">scope_path</span><span class="p">)</span>

        <span class="c1"># TODO Source code reference: This is the line number in the Python</span>
        <span class="c1"># (or FORTRAN?) file. According to meeting on the 21st Feb, 2019,</span>
        <span class="c1"># this was the same as namespace. Exactly same though? Need clarity.</span>

        <span class="n">source_reference</span> <span class="o">=</span> <span class="n">name_space</span>

        <span class="n">iden_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;base_name&quot;</span><span class="p">:</span> <span class="n">base_name</span><span class="p">,</span>
            <span class="s2">&quot;scope&quot;</span><span class="p">:</span> <span class="n">scope_path</span><span class="p">,</span>
            <span class="s2">&quot;namespace&quot;</span><span class="p">:</span> <span class="n">name_space</span><span class="p">,</span>
            <span class="s2">&quot;aliases&quot;</span><span class="p">:</span> <span class="n">aliases</span><span class="p">,</span>
            <span class="s2">&quot;source_references&quot;</span><span class="p">:</span> <span class="n">source_reference</span><span class="p">,</span>
            <span class="s2">&quot;gensyms&quot;</span><span class="p">:</span> <span class="n">generate_gensym</span><span class="p">(</span><span class="n">gensyms_tag</span><span class="p">),</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">iden_dict</span></div>

    <span class="c1"># Create the identifier specification for each identifier</span>
<div class="viewcode-block" id="GrFNGenerator.make_identifier_spec"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.make_identifier_spec">[docs]</a>    <span class="k">def</span> <span class="nf">make_identifier_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">targets</span><span class="p">,</span> <span class="n">sources</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">scope_path</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">scope_path</span>
        <span class="n">for_id</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">if_id</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">identifier_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">item</span><span class="p">,</span> <span class="n">scope</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scope_path</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">scope</span> <span class="o">==</span> <span class="s2">&quot;loop&quot;</span><span class="p">:</span>
                <span class="n">scope_path</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">scope</span> <span class="o">+</span> <span class="s2">&quot;$&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">for_id</span><span class="p">)</span>
                <span class="n">for_id</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">scope</span> <span class="o">==</span> <span class="s2">&quot;if&quot;</span><span class="p">:</span>
                <span class="n">scope_path</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">scope</span> <span class="o">+</span> <span class="s2">&quot;$&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">for_id</span><span class="p">)</span>
                <span class="n">if_id</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Identify which kind of identifier it is</span>
        <span class="n">name_regex</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;(?P&lt;scope&gt;\w+)__(?P&lt;type&gt;\w+)__(?P&lt;basename&gt;\w+)&quot;</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">name_regex</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;assign&quot;</span><span class="p">:</span>
                <span class="n">iden_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_iden_dict</span><span class="p">(</span>
                    <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">),</span> <span class="n">targets</span><span class="p">,</span> <span class="n">scope_path</span><span class="p">,</span> <span class="s2">&quot;body&quot;</span>
                <span class="p">)</span>
                <span class="n">identifier_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iden_dict</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
                        <span class="n">iden_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_iden_dict</span><span class="p">(</span>
                            <span class="n">name</span><span class="p">,</span>
                            <span class="n">item</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]),</span>
                            <span class="n">scope_path</span><span class="p">,</span>
                            <span class="s2">&quot;variable&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">identifier_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iden_dict</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;condition&quot;</span><span class="p">:</span>
                <span class="n">iden_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_iden_dict</span><span class="p">(</span>
                    <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">),</span> <span class="n">targets</span><span class="p">,</span> <span class="n">scope_path</span><span class="p">,</span> <span class="s2">&quot;body&quot;</span>
                <span class="p">)</span>
                <span class="n">identifier_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iden_dict</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
                        <span class="n">iden_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_iden_dict</span><span class="p">(</span>
                            <span class="n">name</span><span class="p">,</span>
                            <span class="n">item</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]),</span>
                            <span class="n">scope_path</span><span class="p">,</span>
                            <span class="s2">&quot;variable&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">identifier_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iden_dict</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;loop_plate&quot;</span><span class="p">:</span>
                <span class="n">iden_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_iden_dict</span><span class="p">(</span>
                    <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">),</span> <span class="n">targets</span><span class="p">,</span> <span class="n">scope_path</span><span class="p">,</span> <span class="s2">&quot;body&quot;</span>
                <span class="p">)</span>
                <span class="n">identifier_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iden_dict</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
                        <span class="n">iden_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_iden_dict</span><span class="p">(</span>
                            <span class="n">name</span><span class="p">,</span>
                            <span class="n">item</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]),</span>
                            <span class="n">scope_path</span><span class="p">,</span>
                            <span class="s2">&quot;variable&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">identifier_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iden_dict</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;decision&quot;</span><span class="p">:</span>
                <span class="n">iden_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_iden_dict</span><span class="p">(</span>
                    <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">),</span> <span class="n">targets</span><span class="p">,</span> <span class="n">scope_path</span><span class="p">,</span> <span class="s2">&quot;body&quot;</span>
                <span class="p">)</span>
                <span class="n">identifier_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iden_dict</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
                        <span class="n">iden_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_iden_dict</span><span class="p">(</span>
                            <span class="n">name</span><span class="p">,</span>
                            <span class="n">item</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]),</span>
                            <span class="n">scope_path</span><span class="p">,</span>
                            <span class="s2">&quot;variable&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">identifier_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iden_dict</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">identifier_list</span></div>

<div class="viewcode-block" id="GrFNGenerator.make_body_dict"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.make_body_dict">[docs]</a>    <span class="k">def</span> <span class="nf">make_body_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">sources</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">source_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
                <span class="n">source_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="s2">&quot;call&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
                <span class="n">source_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">make_call_index_dict</span><span class="p">(</span><span class="n">src</span><span class="p">))</span>

        <span class="c1"># Removing duplicates</span>
        <span class="n">unique_source</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="p">[</span><span class="n">unique_source</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">source_list</span> <span class="k">if</span> <span class="n">obj</span> <span class="ow">not</span> <span class="ow">in</span>
         <span class="n">unique_source</span><span class="p">]</span>
        <span class="n">source_list</span> <span class="o">=</span> <span class="n">unique_source</span>

        <span class="n">id_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_identifier_spec</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">],</span> <span class="n">source_list</span><span class="p">,</span> <span class="n">state</span>
        <span class="p">)</span>

        <span class="n">body</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">],</span> <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="n">source_list</span><span class="p">}</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">body</span><span class="p">,</span> <span class="n">id_spec</span><span class="p">]</span></div>

<div class="viewcode-block" id="GrFNGenerator.make_call_index_dict"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.make_call_index_dict">[docs]</a>    <span class="k">def</span> <span class="nf">make_call_index_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="n">source_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">source</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;inputs&quot;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">item</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">ip</span><span class="p">:</span>
                    <span class="n">source_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ip</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">])</span>
                <span class="k">elif</span> <span class="s2">&quot;call&quot;</span> <span class="ow">in</span> <span class="n">ip</span><span class="p">:</span>
                    <span class="n">source_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">make_call_index_dict</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">source_list</span></div>

<div class="viewcode-block" id="GrFNGenerator.make_source_list_dict"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.make_source_list_dict">[docs]</a>    <span class="k">def</span> <span class="nf">make_source_list_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_dictionary</span><span class="p">):</span>
        <span class="n">source_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">source_dictionary</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
                <span class="n">source_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="s2">&quot;call&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">src</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;inputs&quot;</span><span class="p">]:</span>
                    <span class="n">source_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">make_source_list_dict</span><span class="p">(</span><span class="n">ip</span><span class="p">))</span>

        <span class="c1"># Removing duplicates</span>
        <span class="n">unique_source</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="p">[</span><span class="n">unique_source</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">source_list</span> <span class="k">if</span> <span class="n">obj</span> <span class="ow">not</span> <span class="ow">in</span>
         <span class="n">unique_source</span><span class="p">]</span>
        <span class="n">source_list</span> <span class="o">=</span> <span class="n">unique_source</span>

        <span class="k">return</span> <span class="n">source_list</span></div>

<div class="viewcode-block" id="GrFNGenerator.make_fn_dict"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.GrFNGenerator.make_fn_dict">[docs]</a>    <span class="k">def</span> <span class="nf">make_fn_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">sources</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">source</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Preprocessing and removing certain Assigns which only pertain to the</span>
        <span class="c1"># Python code and do not relate to the FORTRAN code in any way.</span>
        <span class="n">bypass_match_target</span> <span class="o">=</span> <span class="n">RE_BYPASS_IO</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">bypass_match_target</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exclude_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">fn</span>

        <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;call&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
                <span class="c1"># Bypassing identifiers who have I/O constructs on their source</span>
                <span class="c1"># fields too.s</span>
                <span class="c1"># Example: (i[0],) = format_10_obj.read_line(file_10.readline())</span>
                <span class="c1"># &#39;i&#39; is bypassed here</span>
                <span class="c1"># TODO this is only for PETASCE02.for. Will need to include &#39;i&#39;</span>
                <span class="c1">#  in the long run</span>
                <span class="n">bypass_match_source</span> <span class="o">=</span> <span class="n">RE_BYPASS_IO</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">][</span>
                                                              <span class="s2">&quot;function&quot;</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">bypass_match_source</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">exclude_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">exclude_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>
                    <span class="k">return</span> <span class="n">fn</span>
                <span class="k">for</span> <span class="n">source_ins</span> <span class="ow">in</span> <span class="n">make_call_body_dict</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
                    <span class="n">source</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source_ins</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
                <span class="n">variable</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
                <span class="n">source</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">variable</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;variable&quot;</span><span class="p">})</span>

            <span class="c1"># Removing duplicates</span>
            <span class="n">unique_source</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="p">[</span><span class="n">unique_source</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">source</span> <span class="k">if</span> <span class="n">obj</span> <span class="ow">not</span> <span class="ow">in</span>
             <span class="n">unique_source</span><span class="p">]</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">unique_source</span>

            <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\d+&quot;</span><span class="p">,</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span> <span class="ow">and</span> <span class="s2">&quot;list&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
                <span class="c1"># This is a write to a file</span>
                <span class="k">return</span> <span class="n">fn</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;assign&quot;</span><span class="p">,</span>
                <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">],</span>
                <span class="s2">&quot;sources&quot;</span><span class="p">:</span> <span class="n">source</span><span class="p">,</span>
                <span class="s2">&quot;reference&quot;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="p">,</span>
            <span class="p">}</span>

        <span class="k">return</span> <span class="n">fn</span></div></div>


<div class="viewcode-block" id="process_decorators"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.process_decorators">[docs]</a><span class="k">def</span> <span class="nf">process_decorators</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Go through each decorator and extract relevant information.</span>
<span class="sd">        Currently this function only checks for the static_vars decorator</span>
<span class="sd">        for the SAVEd variables and updates variable_types with the data</span>
<span class="sd">        type of each variable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">decorator</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
        <span class="n">decorator_function_name</span> <span class="o">=</span> <span class="n">decorator</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">id</span>
        <span class="k">if</span> <span class="n">decorator_function_name</span> <span class="o">==</span> <span class="s2">&quot;static_vars&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">decorator</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">elts</span><span class="p">:</span>
                <span class="n">variable</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">s</span>
                <span class="n">variable_type</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">s</span>
                <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">ANNOTATE_MAP</span><span class="p">[</span><span class="n">variable_type</span><span class="p">]</span></div>


<div class="viewcode-block" id="genFn"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.genFn">[docs]</a><span class="k">def</span> <span class="nf">genFn</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">function_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">return_value</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="n">lambda_strings</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">argument_strings</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Sort the arguments in the function call as it is used in the operation</span>
    <span class="n">input_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">inputs</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">inputs</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="c1"># Add type annotations to the function arguments</span>
    <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">input_list</span><span class="p">:</span>
        <span class="n">annotation</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">annotation</span><span class="p">:</span>
            <span class="c1"># variable_types does not contain annotations for variables for</span>
            <span class="c1"># indexing</span>
            <span class="c1"># such as &#39;abc_1&#39;, etc. Check if the such variables exist and</span>
            <span class="c1"># assign appropriate annotations</span>
            <span class="n">key_match</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">var</span><span class="p">,</span> <span class="n">dicn</span><span class="p">:</span> <span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dicn</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">var</span><span class="p">])</span>
            <span class="n">annotation</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">[</span>
                    <span class="n">key_match</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">variable_types</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">]</span>
        <span class="n">annotation</span> <span class="o">=</span> <span class="n">ANNOTATE_MAP</span><span class="p">[</span><span class="n">annotation</span><span class="p">]</span>
        <span class="n">argument_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{ip}</span><span class="s2">: </span><span class="si">{annotation}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="n">f</span><span class="s2">&quot;def </span><span class="si">{function_name}</span><span class="s2">({&#39;, &#39;.join(argument_strings)}):</span><span class="se">\n</span><span class="s2">    &quot;</span>
    <span class="p">)</span>
    <span class="c1"># If a `decision` tag comes up, override the call to genCode to manually</span>
    <span class="c1"># enter the python script for the lambda file.</span>
    <span class="k">if</span> <span class="s2">&quot;__decision__&quot;</span> <span class="ow">in</span> <span class="n">function_name</span><span class="p">:</span>
        <span class="n">code</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{inputs[2]}</span><span class="s2"> if </span><span class="si">{inputs[0]}</span><span class="s2"> else </span><span class="si">{inputs[1]}</span><span class="s2">&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">code</span> <span class="o">=</span> <span class="n">genCode</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">PrintState</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    &quot;</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">return_value</span><span class="p">:</span>
        <span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;return </span><span class="si">{code}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">code</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">indent</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;[^ ]&quot;</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="n">indent</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;return &quot;</span> <span class="o">+</span> <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">indent</span><span class="p">:]</span>
        <span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">))</span>
    <span class="n">lambda_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lambda_strings</span><span class="p">)</span></div>


<div class="viewcode-block" id="merge_dictionary"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.merge_dictionary">[docs]</a><span class="k">def</span> <span class="nf">merge_dictionary</span><span class="p">(</span><span class="n">dicts</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Dict</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function merges the entire dictionary created by `gen_grfn` into</span>
<span class="sd">        another dictionary in a managed manner. The `dicts` argument is a</span>
<span class="sd">        list of form [{}, {}, {}] where each {} dictionary is the grfn</span>
<span class="sd">        specification of a function. It contains `functions` and</span>
<span class="sd">        `identifiers` as its keys. Additionally, if the python code has a</span>
<span class="sd">        starting point, that is also present in the last {} of `dicts`. The</span>
<span class="sd">        function merges the values from the `functions` key of each {} in</span>
<span class="sd">        `dicts` into a single key of the same name. Similarly, it does this</span>
<span class="sd">        for every unique key in the `dicts` dictionaries.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fields</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">))</span>
    <span class="n">merged_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">field</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">}</span>

    <span class="c1"># Create a cross-product between each unique key and each grfn dictionary</span>
    <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="n">dicts</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">field</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">merged_dict</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">field</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">merged_dict</span><span class="p">[</span><span class="n">field</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">field</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">merged_dict</span></div>


<div class="viewcode-block" id="get_function_name"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.get_function_name">[docs]</a><span class="k">def</span> <span class="nf">get_function_name</span><span class="p">(</span><span class="n">function_names</span><span class="p">,</span> <span class="n">basename</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="c1"># First, check whether the basename is a &#39;decision&#39; block. If it is, we</span>
    <span class="c1"># need to get it&#39;s index from the index of its corresponding identifier&#39;s</span>
    <span class="c1"># &#39;assign&#39; block. We do not use the index of the &#39;decision&#39; block as that</span>
    <span class="c1"># will not correspond with that of the &#39;assign&#39; block.  For example: for</span>
    <span class="c1"># petpt__decision__albedo, its index will be the index of the latest</span>
    <span class="c1"># petpt__assign__albedo + 1</span>

    <span class="k">if</span> <span class="s2">&quot;__decision__&quot;</span> <span class="ow">in</span> <span class="n">basename</span><span class="p">:</span>
        <span class="n">part_match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;(?P&lt;body&gt;\S+)__decision__(?P&lt;identifier&gt;\S+)&quot;</span><span class="p">,</span> <span class="n">basename</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">part_match</span><span class="p">:</span>
            <span class="n">new_basename</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">part_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;body&quot;</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;__assign__&quot;</span>
                <span class="o">+</span> <span class="n">part_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;identifier&quot;</span><span class="p">)</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_basename</span> <span class="o">=</span> <span class="n">basename</span>
    <span class="n">function_id</span> <span class="o">=</span> <span class="n">function_names</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">new_basename</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;var&quot;</span><span class="p">):</span>
            <span class="n">function_id</span> <span class="o">=</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;index&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">target</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;variable&quot;</span><span class="p">):</span>
            <span class="n">function_id</span> <span class="o">=</span> <span class="n">target</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">function_id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">function_id</span> <span class="o">=</span> <span class="n">function_names</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">new_basename</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">function_name</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{basename}</span><span class="s2">_</span><span class="si">{function_id}</span><span class="s2">&quot;</span>
    <span class="n">function_names</span><span class="p">[</span><span class="n">basename</span><span class="p">]</span> <span class="o">=</span> <span class="n">function_id</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">function_name</span></div>


<div class="viewcode-block" id="get_last_definition"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.get_last_definition">[docs]</a><span class="k">def</span> <span class="nf">get_last_definition</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">last_definitions</span><span class="p">,</span> <span class="n">last_definition_default</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns the last (current) definition (index) of a</span>
<span class="sd">        variable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">last_definition_default</span>

    <span class="c1"># Pre-processing and removing certain Assigns which only pertain to the</span>
    <span class="c1"># Python code and do not relate to the FORTRAN code in any way.</span>
    <span class="n">bypass_match</span> <span class="o">=</span> <span class="n">RE_BYPASS_IO</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">bypass_match</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">last_definitions</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">last_definitions</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">last_definitions</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
        <span class="k">return</span> <span class="n">index</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="get_next_definition"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.get_next_definition">[docs]</a><span class="k">def</span> <span class="nf">get_next_definition</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">last_definitions</span><span class="p">,</span> <span class="n">next_definitions</span><span class="p">,</span>
                        <span class="n">last_definition_default</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns the next definition i.e. index of a variable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The dictionary `next_definitions` holds the next index of all current</span>
    <span class="c1"># variables in scope. If the variable is not found (happens when it is</span>
    <span class="c1"># assigned for the first time in a scope), its index will be one greater</span>
    <span class="c1"># than the last definition default.</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">next_definitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">last_definition_default</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Update the next definition index of this variable by incrementing it by</span>
    <span class="c1"># 1. This will be used the next time when this variable is referenced on</span>
    <span class="c1"># the LHS side of an assignment.</span>
    <span class="n">next_definitions</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="c1"># Also update the `last_definitions` dictionary which holds the current</span>
    <span class="c1"># index of all variables in scope.</span>
    <span class="n">last_definitions</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
    <span class="k">return</span> <span class="n">index</span></div>


<div class="viewcode-block" id="get_variable_type"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.get_variable_type">[docs]</a><span class="k">def</span> <span class="nf">get_variable_type</span><span class="p">(</span><span class="n">annotation_node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns the data type of a variable using the</span>
<span class="sd">        annotation information used to define that variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If the variable has been wrapped in a list like x: List[int],</span>
    <span class="c1"># `annotation_node` will be a Subscript node</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">annotation_node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Subscript</span><span class="p">):</span>
        <span class="n">data_type</span> <span class="o">=</span> <span class="n">annotation_node</span><span class="o">.</span><span class="n">slice</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">id</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data_type</span> <span class="o">=</span> <span class="n">annotation_node</span><span class="o">.</span><span class="n">id</span>
    <span class="k">if</span> <span class="n">ANNOTATE_MAP</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">data_type</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ANNOTATE_MAP</span><span class="p">[</span><span class="n">data_type</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="s2">&quot;Unsupported type (only float, int, list, real, bool and str &quot;</span>
            <span class="s2">&quot;supported as of now).</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="get_body_and_functions"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.get_body_and_functions">[docs]</a><span class="k">def</span> <span class="nf">get_body_and_functions</span><span class="p">(</span><span class="n">pgm</span><span class="p">):</span>
    <span class="n">body</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">stmt</span><span class="p">[</span><span class="s2">&quot;body&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">pgm</span><span class="p">))</span>
    <span class="n">fns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">stmt</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">pgm</span><span class="p">))</span>
    <span class="n">iden_spec</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">stmt</span><span class="p">[</span><span class="s2">&quot;identifiers&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">pgm</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">body</span><span class="p">,</span> <span class="n">fns</span><span class="p">,</span> <span class="n">iden_spec</span></div>


<div class="viewcode-block" id="generate_gensym"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.generate_gensym">[docs]</a><span class="k">def</span> <span class="nf">generate_gensym</span><span class="p">(</span><span class="n">tag</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The gensym is used to uniquely identify any identifier in the</span>
<span class="sd">        program. Python&#39;s uuid library is used to generate a unique 12 digit</span>
<span class="sd">        HEX string. The uuid4() function of &#39;uuid&#39; focuses on randomness.</span>
<span class="sd">        Each and every bit of a UUID v4 is generated randomly and with no</span>
<span class="sd">        inherent logic. To every gensym, we add a tag signifying the data</span>
<span class="sd">        type it represents. &#39;v&#39; is for variables and &#39;h&#39; is for holders.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()</span><span class="o">.</span><span class="n">hex</span><span class="p">[:</span><span class="mi">12</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">tag</span></div>


<div class="viewcode-block" id="make_call_body_dict"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.make_call_body_dict">[docs]</a><span class="k">def</span> <span class="nf">make_call_body_dict</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    We are going to remove addition of functions such as &quot;max&quot;, &quot;exp&quot;, &quot;sin&quot;,</span>
<span class="sd">    etc to the source list. The following two lines when commented helps us do</span>
<span class="sd">    that. If user-defined functions come up as sources, some other approach</span>
<span class="sd">    might be required.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO Try with user defined functions and see if the below two lines need</span>
    <span class="c1">#  to be reworked</span>
    <span class="c1"># name = source[&quot;call&quot;][&quot;function&quot;]</span>
    <span class="c1"># source_list.append({&quot;name&quot;: name, &quot;type&quot;: &quot;function&quot;})</span>

    <span class="n">source_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="n">source</span><span class="p">[</span><span class="s2">&quot;call&quot;</span><span class="p">][</span><span class="s2">&quot;inputs&quot;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">ip</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;var&quot;</span> <span class="ow">in</span> <span class="n">item</span><span class="p">:</span>
                    <span class="n">variable</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">][</span><span class="s2">&quot;variable&quot;</span><span class="p">]</span>
                    <span class="n">source_list</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">variable</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;variable&quot;</span><span class="p">})</span>
                <span class="k">elif</span> <span class="n">item</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dtype&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;string&quot;</span><span class="p">:</span>
                    <span class="c1"># TODO Do repetitions in this like in the above check need</span>
                    <span class="c1">#  to be removed?</span>
                    <span class="n">source_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">item</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">],</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;variable&quot;</span><span class="p">}</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="s2">&quot;call&quot;</span> <span class="ow">in</span> <span class="n">item</span><span class="p">:</span>
                    <span class="n">source_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">make_call_body_dict</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">source_list</span></div>


<div class="viewcode-block" id="remove_io_variables"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.remove_io_variables">[docs]</a><span class="k">def</span> <span class="nf">remove_io_variables</span><span class="p">(</span><span class="n">variable_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function scans each variable from a list of currently defined</span>
<span class="sd">        variables and removes those which are related to I/O such as format</span>
<span class="sd">        variables, file handles, write lists and write_lines.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">io_regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(format_\d+_obj)|(file_\d+)|(write_list_\d+)|&quot;</span>
                          <span class="sa">r</span><span class="s2">&quot;(write_line)&quot;</span><span class="p">)</span>
    <span class="n">io_match_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">io_regex</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variable_list</span><span class="p">]</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">var</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variable_list</span> <span class="k">if</span> <span class="n">io_match_list</span><span class="p">[</span>
        <span class="n">variable_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">var</span><span class="p">)]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">]</span></div>


<div class="viewcode-block" id="dump_ast"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.dump_ast">[docs]</a><span class="k">def</span> <span class="nf">dump_ast</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">annotate_fields</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">include_attributes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="s2">&quot;  &quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a formatted dump of the tree in *node*. This is mainly useful for</span>
<span class="sd">        debugging purposes. The returned string will show the names and the</span>
<span class="sd">        values for fields. This makes the code impossible to evaluate,</span>
<span class="sd">        so if evaluation is wanted *annotate_fields* must be set to False.</span>
<span class="sd">        Attributes such as line numbers and column offsets are not dumped by</span>
<span class="sd">        default. If this is wanted, *include_attributes* can be set to True.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_format</span><span class="p">(</span><span class="n">ast_node</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ast_node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">AST</span><span class="p">):</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">_format</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">level</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span>
                      <span class="n">ast</span><span class="o">.</span><span class="n">iter_fields</span><span class="p">(</span><span class="n">ast_node</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">include_attributes</span> <span class="ow">and</span> <span class="n">ast_node</span><span class="o">.</span><span class="n">_attributes</span><span class="p">:</span>
                <span class="n">fields</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_format</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">ast_node</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">level</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ast_node</span><span class="o">.</span><span class="n">_attributes</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">ast_node</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                    <span class="s2">&quot;(&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">field</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">annotate_fields</span>
                        <span class="k">else</span> <span class="p">(</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">)</span>
                    <span class="p">),</span>
                    <span class="s2">&quot;)&quot;</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ast_node</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;[&quot;</span><span class="p">]</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">indent</span> <span class="o">*</span> <span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">_format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ast_node</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indent</span> <span class="o">*</span> <span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="s2">&quot;]&quot;</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">ast_node</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">AST</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;expected AST, got </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">node</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_format</span><span class="p">(</span><span class="n">node</span><span class="p">)</span></div>


<span class="c1"># Get the absolute path of the python files whose PGMs are being generated.</span>
<span class="c1"># TODO: For now the path is started from the directory &quot;for2py&quot; but need further</span>
<span class="c1">#  discussion on this</span>
<div class="viewcode-block" id="get_path"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.get_path">[docs]</a><span class="k">def</span> <span class="nf">get_path</span><span class="p">(</span><span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">instance</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="n">absolute_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">instance</span> <span class="o">==</span> <span class="s2">&quot;namespace&quot;</span><span class="p">:</span>
        <span class="n">path_match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*/(for2py/.*).py$&quot;</span><span class="p">,</span> <span class="n">absolute_path</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">instance</span> <span class="o">==</span> <span class="s2">&quot;source&quot;</span><span class="p">:</span>
        <span class="n">path_match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*/(for2py/.*$)&quot;</span><span class="p">,</span> <span class="n">absolute_path</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">path_match</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">path_match</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">path_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">file_name</span></div>


<div class="viewcode-block" id="create_grfn_dict"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.create_grfn_dict">[docs]</a><span class="k">def</span> <span class="nf">create_grfn_dict</span><span class="p">(</span>
    <span class="n">lambda_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">asts</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span>
    <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">mode_mapper_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="n">original_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">save_file</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a Python dict representing the GrFN, with additional metadata for</span>
<span class="sd">        JSON output.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">lambda_string_list</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="s2">&quot;from numbers import Real</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;import delphi.translators.for2py.math_ext as math</span><span class="se">\n\n</span><span class="s2">&quot;</span>
    <span class="p">]</span>

    <span class="n">state</span> <span class="o">=</span> <span class="n">GrFNState</span><span class="p">(</span><span class="n">lambda_string_list</span><span class="p">)</span>
    <span class="n">generator</span> <span class="o">=</span> <span class="n">GrFNGenerator</span><span class="p">()</span>
    <span class="n">generator</span><span class="o">.</span><span class="n">mode_mapper</span> <span class="o">=</span> <span class="n">mode_mapper_dict</span>
    <span class="n">generator</span><span class="o">.</span><span class="n">fortran_file</span> <span class="o">=</span> <span class="n">original_file</span>
    <span class="n">grfn</span> <span class="o">=</span> <span class="n">generator</span><span class="o">.</span><span class="n">gen_grfn</span><span class="p">(</span><span class="n">asts</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># If the GrFN has a `start` node, it will refer to the name of the</span>
    <span class="c1"># PROGRAM module which will be the entry point of the GrFN.</span>
    <span class="k">if</span> <span class="n">grfn</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;start&quot;</span><span class="p">):</span>
        <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># TODO: If the PROGRAM module is not detected, the entry point will be</span>
        <span class="c1">#  the last function in the `function_defs` list of functions</span>
        <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">generator</span><span class="o">.</span><span class="n">function_definitions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Finding the original Fortran source file being analyzed.</span>
    <span class="n">source_match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[./]*(.*)&#39;</span><span class="p">,</span> <span class="n">original_file</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">source_match</span><span class="p">,</span> <span class="n">f</span><span class="s2">&quot;Original Fortran source file for </span><span class="si">{file_name}</span><span class="s2"> not &quot;</span> \
        <span class="n">f</span><span class="s2">&quot;found.&quot;</span>
    <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">source_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>

    <span class="c1"># dateCreated stores the date and time on which the lambda and GrFN files</span>
    <span class="c1"># were created. It is stored in the YYYMMDD format</span>
    <span class="n">grfn</span><span class="p">[</span><span class="s2">&quot;date_created&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;{datetime.utcnow().isoformat(&#39;T&#39;)}Z&quot;</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">lambda_file</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">lambda_fh</span><span class="p">:</span>
        <span class="n">lambda_fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lambda_string_list</span><span class="p">))</span>

    <span class="c1"># View the PGM file that will be used to build a scope tree</span>
    <span class="k">if</span> <span class="n">save_file</span><span class="p">:</span>
        <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">grfn</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">[:</span><span class="n">file_name</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)]</span> <span class="o">+</span> <span class="s2">&quot;.json&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">grfn</span></div>


<div class="viewcode-block" id="generate_ast"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.generate_ast">[docs]</a><span class="k">def</span> <span class="nf">generate_ast</span><span class="p">(</span><span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function generates the AST of a python file using Python&#39;s ast</span>
<span class="sd">        module.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">tokenize</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">())</span></div>


<div class="viewcode-block" id="get_asts_from_files"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.get_asts_from_files">[docs]</a><span class="k">def</span> <span class="nf">get_asts_from_files</span><span class="p">(</span><span class="n">file_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">printast</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns the AST of each python file in the</span>
<span class="sd">        python_file_list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ast_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">file_list</span><span class="p">:</span>
        <span class="n">ast_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">generate_ast</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">printast</span><span class="p">:</span>
            <span class="c1"># If the printAst flag is set, print the AST to console</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">dump_ast</span><span class="p">(</span><span class="n">ast_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">ast_list</span></div>


<div class="viewcode-block" id="get_system_name"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.get_system_name">[docs]</a><span class="k">def</span> <span class="nf">get_system_name</span><span class="p">(</span><span class="n">pyfile_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function returns the name of the system under analysis. Generally,</span>
<span class="sd">    the system is the one which is not prefixed by `m_` (which represents</span>
<span class="sd">    modules).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">system_name</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">path</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">pyfile_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">file</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;m_&quot;</span><span class="p">):</span>
            <span class="n">system_name_match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.*/(.*)\.py&#39;</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">system_name_match</span><span class="p">,</span> <span class="n">f</span><span class="s2">&quot;System name for file </span><span class="si">{file}</span><span class="s2"> not found.&quot;</span>
            <span class="n">system_name</span> <span class="o">=</span> <span class="n">system_name_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">path_match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(.*)/.*&#39;</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">path_match</span><span class="p">,</span> <span class="s2">&quot;Target path not found&quot;</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">path_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">system_name</span> <span class="ow">or</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="n">f</span><span class="s2">&quot;Error when trying to find the system name of the &quot;</span> \
            <span class="n">f</span><span class="s2">&quot;analyzed program.&quot;</span>

    <span class="k">return</span> <span class="n">system_name</span><span class="p">,</span> <span class="n">path</span></div>


<div class="viewcode-block" id="generate_system_def"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.generate_system_def">[docs]</a><span class="k">def</span> <span class="nf">generate_system_def</span><span class="p">(</span><span class="n">python_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">component_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function generates the system definition for the system under</span>
<span class="sd">        analysis and writes this to the main system file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">(</span><span class="n">system_name</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="o">=</span> <span class="n">get_system_name</span><span class="p">(</span><span class="n">python_list</span><span class="p">)</span>
    <span class="n">system_filename</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{path}</span><span class="s2">/system.json&quot;</span>
    <span class="n">grfn_components</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">component_list</span><span class="p">:</span>
        <span class="n">grfn_components</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
            <span class="s2">&quot;file_path&quot;</span><span class="p">:</span> <span class="n">component</span><span class="p">,</span>
            <span class="s2">&quot;imports&quot;</span><span class="p">:</span> <span class="p">[]</span>
        <span class="p">})</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">system_filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">system_file</span><span class="p">:</span>
        <span class="n">system_def</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;date_created&quot;</span><span class="p">:</span> <span class="n">f</span><span class="s2">&quot;{datetime.utcnow().isoformat(&#39;T&#39;)}Z&quot;</span><span class="p">,</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">system_name</span><span class="p">,</span>
            <span class="s2">&quot;components&quot;</span><span class="p">:</span> <span class="n">grfn_components</span>
        <span class="p">}</span>
        <span class="n">system_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">system_def</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span></div>


<div class="viewcode-block" id="process_files"><a class="viewcode-back" href="../../../../delphi.translators.for2py.html#delphi.translators.for2py.genPGM.process_files">[docs]</a><span class="k">def</span> <span class="nf">process_files</span><span class="p">(</span><span class="n">python_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">grfn_tail</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">lambda_tail</span><span class="p">:</span>
                  <span class="nb">str</span><span class="p">,</span> <span class="n">original_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">print_ast_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function takes in the list of python files to convert into GrFN </span>
<span class="sd">        and generates each file&#39;s AST along with starting the GrFN generation</span>
<span class="sd">        process. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">module_mapper</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">grfn_filepath_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ast_list</span> <span class="o">=</span> <span class="n">get_asts_from_files</span><span class="p">(</span><span class="n">python_list</span><span class="p">,</span> <span class="n">print_ast_flag</span><span class="p">)</span>

    <span class="c1"># Regular expression to identify the path and name of all python files</span>
    <span class="n">filename_regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?P&lt;path&gt;.*/)(?P&lt;filename&gt;.*).py&quot;</span><span class="p">)</span>

    <span class="c1"># First, find the main python file in order to populate the module</span>
    <span class="c1"># mapper</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">python_list</span><span class="p">:</span>
        <span class="n">file_match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">filename_regex</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">file_match</span><span class="p">,</span> <span class="s2">&quot;Invalid filename.&quot;</span>

        <span class="n">path</span> <span class="o">=</span> <span class="n">file_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;path&quot;</span><span class="p">)</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">file_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;filename&quot;</span><span class="p">)</span>

        <span class="c1"># Ignore all python files of modules created by `pyTranslate.py`</span>
        <span class="c1"># since these module files do not contain a corresponding XML file.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">filename</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;m_&quot;</span><span class="p">):</span>
            <span class="n">xml_file</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{path}</span><span class="s2">rectified_</span><span class="si">{filename}</span><span class="s2">.xml&quot;</span>
            <span class="c1"># Calling the `get_index` function in `mod_index_generator.py` to</span>
            <span class="c1"># map all variables and objects in the various files</span>
            <span class="n">module_mapper</span> <span class="o">=</span> <span class="n">get_index</span><span class="p">(</span><span class="n">xml_file</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">ast_string</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ast_list</span><span class="p">):</span>
        <span class="n">lambda_file</span> <span class="o">=</span> <span class="n">python_list</span><span class="p">[</span><span class="n">index</span><span class="p">][:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">lambda_tail</span>
        <span class="n">grfn_file</span> <span class="o">=</span> <span class="n">python_list</span><span class="p">[</span><span class="n">index</span><span class="p">][:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">grfn_tail</span>
        <span class="n">grfn_dict</span> <span class="o">=</span> <span class="n">create_grfn_dict</span><span class="p">(</span>
            <span class="n">lambda_file</span><span class="p">,</span> <span class="p">[</span><span class="n">ast_string</span><span class="p">],</span> <span class="n">python_list</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">module_mapper</span><span class="p">,</span>
            <span class="n">original_file</span>
        <span class="p">)</span>
        <span class="n">grfn_filepath_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">grfn_file</span><span class="p">)</span>
        <span class="c1"># Write each GrFN JSON into a file</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">grfn_file</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_handle</span><span class="p">:</span>
            <span class="n">file_handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">grfn_dict</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>

    <span class="c1"># Finally, write the &lt;systems.json&gt; file which gives a mapping of all the</span>
    <span class="c1"># GrFN files related to the system.</span>
    <span class="n">generate_system_def</span><span class="p">(</span><span class="n">python_list</span><span class="p">,</span> <span class="n">grfn_filepath_list</span><span class="p">)</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-f&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--files&quot;</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">,</span>
        <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;A list of python files to generate a PGM for&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-p&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--grfn_suffix&quot;</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Filename for the output PGM&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-l&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--lambda_suffix&quot;</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Filename for output lambda functions&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-o&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--out&quot;</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Text file containing the list of output python files being &quot;</span>
             <span class="s2">&quot;generated&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-a&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--print_ast&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
        <span class="n">required</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Print ASTs&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-g&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--original_file&quot;</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Filename of the original Fortran file&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">arguments</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="c1"># Read the outputFile which contains the name of all the python files</span>
    <span class="c1"># generated by `pyTranslate.py`. Multiple files occur in the case of</span>
    <span class="c1"># modules since each module is written out into a separate python file.</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">arguments</span><span class="o">.</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">python_files</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="c1"># The Python file names are space separated. Append each one to a list.</span>
    <span class="n">python_file_list</span> <span class="o">=</span> <span class="n">python_files</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>

    <span class="n">grfn_suffix</span> <span class="o">=</span> <span class="n">arguments</span><span class="o">.</span><span class="n">grfn_suffix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">lambda_suffix</span> <span class="o">=</span> <span class="n">arguments</span><span class="o">.</span><span class="n">lambda_suffix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">fortran_file</span> <span class="o">=</span> <span class="n">arguments</span><span class="o">.</span><span class="n">original_file</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">print_ast</span> <span class="o">=</span> <span class="n">arguments</span><span class="o">.</span><span class="n">print_ast</span>

    <span class="n">process_files</span><span class="p">(</span><span class="n">python_file_list</span><span class="p">,</span> <span class="n">grfn_suffix</span><span class="p">,</span> <span class="n">lambda_suffix</span><span class="p">,</span> <span class="n">fortran_file</span><span class="p">,</span>
                  <span class="n">print_ast</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Adarsh

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>